<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ingredient List Consolidator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        function IngredientConsolidator() {
            const [lists, setLists] = useState(['', '', '']);
            const [consolidated, setConsolidated] = useState([]);
            const [copyStatus, setCopyStatus] = useState('');
            const [summary, setSummary] = useState(null);
            const [hasConversions, setHasConversions] = useState(false);
            const [apiKey, setApiKey] = useState(localStorage.getItem('googleSheetsApiKey') || '');
            const [masterData, setMasterData] = useState(null);
            const [loadingMaster, setLoadingMaster] = useState(false);
            const [masterError, setMasterError] = useState('');
            const [matchSuggestions, setMatchSuggestions] = useState([]);
            const [showMatchModal, setShowMatchModal] = useState(false);
            const [pendingMatches, setPendingMatches] = useState({});

            const SHEET_ID = '1yJyhd23X77zH_ITtQu1AtNTI-Ak9KnorymsPJgEJKMc';
            const SHEET_NAME = 'Master List_Annapurna'; // Adjust if needed
            const API_KEY = 'AIzaSyAxFgijOuH0PeE-wmK3DBG2XqmHNnnabyE'; // Set your Google Sheets API key here
            

            // Load master data on mount if API key is set
            useEffect(() => {
                if (API_KEY) {
                    setApiKey(API_KEY);
                }
            }, []);

            // Load master data when API key changes
            useEffect(() => {
                if (apiKey) {
                    loadMasterData();
                }
            }, [apiKey]);

            async function loadMasterData() {
                setLoadingMaster(true);
                setMasterError('');
                
                try {
                    const range = `${SHEET_NAME}!A:F`; // Items, Default Unit, Preferred Brand, Category, Preferred Store, Alt Store
                    const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/Master_Items?key=${apiKey}`;
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error('Failed to fetch master data. Check your API key.');
                    }
                    
                    const data = await response.json();
                    const rows = data.values || [];
                    
                    // Skip header row, create master lookup with category grouping
                    const masterLookup = {};
                    const categoryIndex = {};
                    
                    for (let i = 1; i < rows.length; i++) {
                        const [item, defaultUnit, preferredBrand, category, preferredStore, altStore] = rows[i];
                        if (item) {
                            const itemLower = item.toLowerCase().trim();
                            const categoryLower = (category || '').toLowerCase().trim();
                            
                            masterLookup[itemLower] = {
                                item: item,
                                defaultUnit: defaultUnit || '',
                                preferredBrand: preferredBrand || '',
                                category: category || '',
                                preferredStore: preferredStore || '',
                                altStore: altStore || ''
                            };
                            
                            // Build category index for context-aware matching
                            if (categoryLower) {
                                if (!categoryIndex[categoryLower]) {
                                    categoryIndex[categoryLower] = [];
                                }
                                categoryIndex[categoryLower].push({
                                    key: itemLower,
                                    data: masterLookup[itemLower]
                                });
                            }
                        }
                    }
                    
                    setMasterData({ lookup: masterLookup, categoryIndex: categoryIndex });
                    setLoadingMaster(false);
                } catch (error) {
                    setMasterError(error.message);
                    setLoadingMaster(false);
                }
            }

            function saveApiKey() {
                localStorage.setItem('googleSheetsApiKey', apiKey);
                loadMasterData();
            }

            // Enhanced fuzzy matching with category context and synonym support
            function fuzzyMatchWithCategory(input, masterData, threshold = 0.5) {
                const inputLower = input.toLowerCase();
                const { lookup, categoryIndex } = masterData;
                const matches = [];
                
                // Synonym mapping for common ingredient variations
                const synonyms = {
                    'coriander': 'cilantro',
                    'coriander leaf': 'cilantro',
                    'curry leaf': 'curry leaves',
                    'tomato': 'tomatoes'
                };
                
                // Check if input has a known synonym
                let searchTerm = inputLower;
                for (const [key, value] of Object.entries(synonyms)) {
                    if (inputLower.includes(key)) {
                        searchTerm = inputLower.replace(key, value);
                        break;
                    }
                }
                
                // Extract main noun (last word) and adjectives (other words)
                const inputWords = searchTerm.split(/\s+/);
                const inputNoun = inputWords[inputWords.length - 1]; // e.g., "chana" from "black chana"
                const inputAdjectives = inputWords.slice(0, -1); // e.g., ["black"] from "black chana"
                
                // First pass: Look for matches and determine likely category
                let likelyCategory = null;
                let maxInitialSimilarity = 0;
                
                for (const [key, data] of Object.entries(lookup)) {
                    const similarity = calculateSimilarity(searchTerm, key);
                    if (similarity > maxInitialSimilarity) {
                        maxInitialSimilarity = similarity;
                        likelyCategory = data.category.toLowerCase();
                    }
                }
                
                // Second pass: Score matches with category boost and noun-based matching
                for (const [key, data] of Object.entries(lookup)) {
                    let similarity = calculateSimilarity(searchTerm, key);
                    
                    // Boost matches that contain the main noun
                    const masterWords = key.split(/\s+/);
                    const masterNoun = masterWords[masterWords.length - 1];
                    
                    // If master item contains the input noun, boost similarity
                    if (key.includes(inputNoun)) {
                        similarity = Math.min(1.0, similarity * 1.2); // 20% boost for noun match
                    }
                    
                    // Boost similarity if in the same category as the likely match
                    if (likelyCategory && data.category.toLowerCase() === likelyCategory) {
                        similarity = Math.min(1.0, similarity * 1.3); // 30% boost for same category
                    }
                    
                    if (similarity >= threshold) {
                        matches.push({ 
                            key, 
                            data, 
                            similarity,
                            categoryMatch: data.category.toLowerCase() === likelyCategory,
                            nounMatch: key.includes(inputNoun)
                        });
                    }
                }
                
                // Sort by: noun match first, then similarity, then category match
                return matches.sort((a, b) => {
                    // Prioritize noun matches
                    if (a.nounMatch && !b.nounMatch) return -1;
                    if (!a.nounMatch && b.nounMatch) return 1;
                    
                    // Then by similarity
                    if (Math.abs(a.similarity - b.similarity) > 0.05) {
                        return b.similarity - a.similarity;
                    }
                    
                    // Then by category match
                    if (a.categoryMatch && !b.categoryMatch) return -1;
                    if (!a.categoryMatch && b.categoryMatch) return 1;
                    
                    return 0;
                }).slice(0, 8); // Show up to 8 matches
            }

            // Simple similarity calculation (Levenshtein-inspired)
            function calculateSimilarity(str1, str2) {
                const longer = str1.length > str2.length ? str1 : str2;
                const shorter = str1.length > str2.length ? str2 : str1;
                
                if (longer.length === 0) return 1.0;
                
                // Handle common singular/plural variations
                const singularToPlural = {
                    'tomato': 'tomatoes', 'potato': 'potatoes', 'leaf': 'leaves', 'leaves': 'leaves'
                };
                const pluralToSingular = {
                    'tomatoes': 'tomato', 'potatoes': 'potato', 'leaves': 'leaf'
                };
                
                // Check if one is singular and other is plural of same word
                if (singularToPlural[shorter] === longer || pluralToSingular[shorter] === longer ||
                    singularToPlural[longer] === shorter || pluralToSingular[longer] === shorter) {
                    return 0.95; // High similarity for singular/plural pairs
                }
                
                // Split into words for analysis
                const shorterWords = shorter.split(/\s+/);
                const longerWords = longer.split(/\s+/);
                
                // Check for word overlap - at least one main word should match
                const commonWords = shorterWords.filter(word => 
                    longerWords.some(lw => {
                        // Also check singular/plural forms
                        return lw.includes(word) || word.includes(lw) || 
                               singularToPlural[word] === lw || pluralToSingular[word] === lw ||
                               singularToPlural[lw] === word || pluralToSingular[lw] === word;
                    })
                );
                
                // If no common words at all, very low similarity
                if (commonWords.length === 0) {
                    return 0.3;
                }
                
                // Check if shorter is contained in longer
                if (longer.includes(shorter)) {
                    // If input (shorter) is a complete word match in master (longer)
                    
                    // If input is single word and master has multiple words
                    if (shorterWords.length === 1 && longerWords.length > 1) {
                        // Check if the single word is an exact match to one of the words (or singular/plural)
                        const exactWordMatch = longerWords.some(word => {
                            return word === shorter || 
                                   singularToPlural[shorter] === word || 
                                   pluralToSingular[shorter] === word;
                        });
                        
                        if (exactWordMatch) {
                            // Check if other words are descriptors
                            const otherWords = longerWords.filter(word => 
                                word !== shorter && 
                                singularToPlural[shorter] !== word && 
                                pluralToSingular[shorter] !== word
                            );
                            const descriptors = ['frozen', 'fresh', 'canned', 'dried', 'raw', 'cooked', 
                                               'baby', 'red', 'white', 'green', 'yellow', 'black', 
                                               'organic', 'large', 'small', 'whole', 'chopped', 'diced',
                                               'sliced', 'ground'];
                            const hasOnlyDescriptors = otherWords.every(word => descriptors.includes(word.toLowerCase()));
                            
                            if (hasOnlyDescriptors) {
                                // "spinach" â†’ "baby spinach" or "onion" â†’ "red onion"
                                return 0.80; // High enough to show in resolution but not auto-match
                            } else {
                                // "potato" â†’ "potato chips" (chips is not a descriptor)
                                return 0.60;
                            }
                        } else {
                            return 0.5;
                        }
                    }
                    
                    // If word counts are the same or similar, high score
                    if (Math.abs(shorterWords.length - longerWords.length) <= 1) {
                        return 0.9;
                    }
                    
                    return 0.8;
                }
                
                // Calculate edit distance
                const editDistance = levenshteinDistance(str1, str2);
                return (longer.length - editDistance) / longer.length;
            }

            function levenshteinDistance(str1, str2) {
                const matrix = [];
                
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[str2.length][str1.length];
            }

            function parseQuantity(text) {
                const patterns = [
                    /(\d+\.?\d*)\s*(lbs?|pounds?)/gi,
                    /(\d+\.?\d*)\s*(oz|ounces?)/gi,
                    /(\d+\.?\d*)\s*(gallons?)/gi,
                    /(\d+\.?\d*)\s*(cups?)/gi,
                    /(\d+\.?\d*)\s*(packs?|packets?)/gi,
                    /(\d+\.?\d*)\s*(jars?)/gi,
                    /(\d+\.?\d*)\s*(bottles?)/gi,
                    /(\d+\.?\d*)\s*(blocks?)/gi,
                    /(\d+\.?\d*)\s*(boxes?)/gi,
                    /(\d+\.?\d*)\s*(bunches?)/gi,
                    /(\d+\.?\d*)\s*(cartons?)/gi,
                    /(\d+\.?\d*)\s*(stalks?)/gi,
                    /(\d+\.?\d*)\s*(cloves?)/gi,
                    /(\d+\.?\d*)\s*(count)/gi,
                    /(\d+\.?\d*)\s*(cans?)/gi,
                    /(\d+\.?\d*)\s*(tins?)/gi,
                    /(\d+\.?\d*)\s*(bags?)/gi,
                    /(\d+\.?\d*)\s*(sticks?)/gi,
                    /(\d+\.?\d*)\s*(gms?|grams?)/gi,
                ];

                let lastMatch = null;
                let lastMatchIndex = -1;
                for (let pattern of patterns) {
                    const matches = [...text.matchAll(pattern)];
                    if (matches.length > 0) {
                        const match = matches[matches.length - 1];
                        if (match.index > lastMatchIndex) {
                            lastMatch = match;
                            lastMatchIndex = match.index;
                        }
                    }
                }

                if (lastMatch) {
                    let quantity = parseFloat(lastMatch[1]);
                    const beforeMatch = text.substring(0, lastMatch.index);
                    const rangeMatch = beforeMatch.match(/(\d+\.?\d*)\s*-\s*$/);
                    if (rangeMatch) {
                        quantity = parseFloat(lastMatch[1]);
                    }
                    return { quantity: quantity, unit: lastMatch[2].toLowerCase() };
                }

                const rangeMatch = text.match(/(\d+\.?\d*)\s*-\s*(\d+\.?\d*)/g);
                if (rangeMatch) {
                    const lastRange = rangeMatch[rangeMatch.length - 1];
                    const rangeParts = lastRange.match(/(\d+\.?\d*)\s*-\s*(\d+\.?\d*)/);
                    return { quantity: parseFloat(rangeParts[2]), unit: 'count' };
                }
                
                const allNumbers = [...text.matchAll(/(\d+\.?\d*)/g)];
                if (allNumbers.length > 0) {
                    const lastNumber = allNumbers[allNumbers.length - 1];
                    return { quantity: parseFloat(lastNumber[1]), unit: 'count' };
                }

                return { quantity: 0, unit: 'pantry' };
            }

            function normalizeUnit(unit, quantity) {
                if (unit === 'cup' || unit === 'cups') {
                    return { unit: 'lbs', quantity: quantity / 2, converted: true };
                }
                
                const unitMap = {
                    'lb': 'lbs', 'pound': 'lbs', 'pounds': 'lbs',
                    'oz': 'oz', 'ounce': 'oz', 'ounces': 'oz',
                    'gallon': 'gallons',
                    'pack': 'packs', 'packet': 'packs', 'packets': 'packs',
                    'jar': 'jars', 'bottle': 'bottles', 'block': 'blocks',
                    'box': 'boxes', 'bunch': 'bunches', 'carton': 'cartons',
                    'stalk': 'stalks', 'clove': 'cloves',
                    'can': 'cans', 'cans': 'cans',
                    'tin': 'tins', 'tins': 'tins',
                    'bag': 'bags', 'bags': 'bags',
                    'stick': 'sticks', 'sticks': 'sticks',
                    'gm': 'gms', 'gms': 'gms', 'gram': 'gms', 'grams': 'gms',
                };
                return { unit: unitMap[unit] || unit, quantity: quantity, converted: false };
            }

            function normalizeIngredientName(name) {
                let normalized = name.toLowerCase().trim();
                normalized = normalized.replace(/-/g, ' ');
                
                const isPepper = normalized.includes('pepper') && !normalized.includes('crushed') && !normalized.includes('flakes');
                const isBread = normalized.includes('bread') || normalized.includes('rice');
                const isChili = normalized.includes('chili') || normalized.includes('chilli');
                const isApple = normalized.includes('apple');
                const isOnion = normalized.includes('onion');
                const isTomato = normalized.includes('tomato');
                const isBellPepper = normalized.includes('bell');
                const isPeas = normalized.includes('peas') || normalized.includes('vatana');
                const isPumpkin = normalized.includes('pumpkin') || normalized.includes('guard');
                
                const removeWords = [
                    'twin pack', 'costco', 'restaurant depot', 'trader joe',
                    'organic', 'extra virgin', 'virgin', 'unsalted', 'salted',
                    'fresh', 'frozen', 'canned',
                    'shredded', 'diced', 'chopped', 'sliced', 'whole', 'peeled',
                    'flat leaf', 'baby', 'purÃ©e', 'puree', 'pantry'
                ];
                
                if (!isPepper && !isBread && !isChili && !isApple && !isOnion && !isTomato && !isBellPepper && !isPeas && !isPumpkin) {
                    removeWords.push('red', 'green', 'yellow', 'white', 'black', 'purple');
                }
                
                removeWords.forEach(word => {
                    const regex = new RegExp('\\b' + word + '\\b', 'gi');
                    normalized = normalized.replace(regex, '');
                });
                
                normalized = normalized.replace(/\s*\/\s*/g, '/');
                normalized = normalized.replace(/\s+/g, ' ').trim();
                normalized = normalized.replace(/\s*â€“\s*/g, ' ');
                normalized = normalized.replace(/\s*-\s*/g, ' ');
                normalized = normalized.replace(/\s+/g, ' ').trim();
                
                normalized = normalized.replace(/\bgarlic\s+clove[s]?\b/gi, 'garlic');
                
                const pluralMap = {
                    'tomatoes': 'tomato', 'potatoes': 'potato', 'onions': 'onion',
                    'carrots': 'carrot', 'peppers': 'pepper',
                    'chilies': 'chili', 'chillies': 'chili',
                    'lemons': 'lemon', 'limes': 'lime',
                    'leaves': 'leaf', 'bunches': 'bunch',
                };
                
                for (let [plural, singular] of Object.entries(pluralMap)) {
                    const regex = new RegExp('\\b' + plural + '\\b', 'gi');
                    normalized = normalized.replace(regex, singular);
                }
                
                return normalized;
            }

            function parseIngredientLine(line) {
                line = line.replace(/[\u2060\u200B\u200C\u200D\uFEFF]/g, '');
                line = line.trim();
                if (!line) return null;
                
                line = line.replace(/^[â€¢\-\*]\s*/, '');
                line = line.replace(/^\d+[\.)]\s*/, '');
                line = line.trim();
                
                const parenContents = [];
                let protectedLine = line.replace(/\([^)]+\)/g, (match) => {
                    parenContents.push(match);
                    return `__PAREN_${parenContents.length - 1}__`;
                });

                const parsed = parseQuantity(protectedLine);
                let ingredientName = protectedLine;
                
                if (parsed.quantity > 0) {
                    const unitPattern = /(\d+\.?\d*\s*-\s*)?(\d+\.?\d*)\s*(lbs?|pounds?|oz|ounces?|gallons?|cups?|packs?|packets?|jars?|bottles?|blocks?|boxes?|bunches?|cartons?|stalks?|cloves?|count|cans?|tins?|bags?|sticks?|gms?|grams?)\b/gi;
                    const matches = [...protectedLine.matchAll(unitPattern)];
                    
                    if (matches.length > 0) {
                        const lastMatch = matches[matches.length - 1];
                        const beforeMatch = protectedLine.substring(0, lastMatch.index);
                        const afterMatch = protectedLine.substring(lastMatch.index + lastMatch[0].length);
                        ingredientName = (beforeMatch + afterMatch).trim();
                    } else {
                        const rangeMatches = [...protectedLine.matchAll(/(\d+\.?\d*)\s*-\s*(\d+\.?\d*)/g)];
                        if (rangeMatches.length > 0) {
                            const lastRangeMatch = rangeMatches[rangeMatches.length - 1];
                            const beforeRange = protectedLine.substring(0, lastRangeMatch.index);
                            const afterRange = protectedLine.substring(lastRangeMatch.index + lastRangeMatch[0].length);
                            ingredientName = (beforeRange + afterRange).trim();
                        } else {
                            const numberMatches = [...protectedLine.matchAll(/(\d+\.?\d*)/g)];
                            if (numberMatches.length > 0) {
                                const lastNumMatch = numberMatches[numberMatches.length - 1];
                                const beforeNum = protectedLine.substring(0, lastNumMatch.index);
                                const afterNum = protectedLine.substring(lastNumMatch.index + lastNumMatch[0].length);
                                ingredientName = (beforeNum + afterNum).trim();
                            }
                        }
                    }
                }
                
                ingredientName = ingredientName.replace(/__PAREN_(\d+)__/g, (match, index) => {
                    return parenContents[parseInt(index)];
                });

                ingredientName = normalizeIngredientName(ingredientName);
                
                if (!ingredientName || ingredientName.length === 0) {
                    return null;
                }

                const normalized = normalizeUnit(parsed.unit, parsed.quantity);

                return {
                    normalized: ingredientName,
                    quantity: normalized.quantity,
                    unit: normalized.unit,
                    isPantry: parsed.unit === 'pantry',
                    converted: normalized.converted
                };
            }

            function consolidateIngredients() {
                if (!masterData) {
                    alert('Please load master data first by entering your Google Sheets API key.');
                    return;
                }

                const allIngredients = {};
                const listStats = [];
                let totalInputItems = 0;
                let conversionsDetected = false;

                const numberedLists = lists.map(list => {
                    if (!list.trim()) return list;
                    const lines = list.split('\n');
                    let lineNumber = 1;
                    return lines.map(line => {
                        if (line.trim()) {
                            return `${lineNumber++}. ${line}`;
                        }
                        return '';
                    }).filter(line => line !== '').join('\n');
                });
                setLists(numberedLists);

                lists.forEach((list, listIndex) => {
                    if (!list.trim()) return;

                    let itemCount = 0;
                    const lines = list.split('\n');
                    
                    lines.forEach(line => {
                        const ingredient = parseIngredientLine(line);
                        if (!ingredient) return;

                        itemCount++;
                        totalInputItems++;
                        
                        if (ingredient.converted) {
                            conversionsDetected = true;
                        }

                        if (!allIngredients[ingredient.normalized]) {
                            allIngredients[ingredient.normalized] = {
                                quantities: {},
                                isPantry: ingredient.isPantry,
                                sources: [],
                                originalName: ingredient.normalized
                            };
                        }

                        const entry = allIngredients[ingredient.normalized];
                        
                        if (ingredient.isPantry) {
                            entry.isPantry = true;
                        } else {
                            if (!entry.quantities[ingredient.unit]) {
                                entry.quantities[ingredient.unit] = 0;
                            }
                            entry.quantities[ingredient.unit] += ingredient.quantity;
                            entry.isPantry = false;
                        }
                        
                        entry.sources.push(listIndex + 1);
                    });

                    if (itemCount > 0) {
                        listStats.push({
                            listNumber: listIndex + 1,
                            itemCount: itemCount
                        });
                    }
                });

                setHasConversions(conversionsDetected);

                // Step 1: Match with master data (don't consolidate yet)
                const needsMatching = {};
                const matchedIngredients = {};
                
                for (const [name, item] of Object.entries(allIngredients)) {
                    // Try exact match first
                    let masterMatch = masterData.lookup[name];
                    let matchStatus = 'exact';
                    
                    // If no exact match, try fuzzy matching with category context
                    if (!masterMatch) {
                        const fuzzyMatches = fuzzyMatchWithCategory(name, masterData);
                        
                        // Auto-match only for VERY high similarity (>95%) to avoid false matches
                        if (fuzzyMatches.length > 0 && fuzzyMatches[0].similarity > 0.95) {
                            // Auto-match if very high similarity (>95%)
                            masterMatch = fuzzyMatches[0].data;
                            matchStatus = 'auto-fuzzy';
                        } else if (fuzzyMatches.length > 0 && fuzzyMatches[0].similarity >= 0.5) {
                            // Show matches for user selection
                            // Don't filter too aggressively - show all reasonable matches
                            let filteredMatches = fuzzyMatches;
                            
                            // Only filter out very different categories if there's a strong category signal
                            const hasCategoryMatch = fuzzyMatches.some(m => m.categoryMatch);
                            const topSimilarity = fuzzyMatches[0].similarity;
                            
                            // Only filter if we have category matches AND non-category items are significantly worse
                            if (hasCategoryMatch && topSimilarity > 0.8) {
                                // Keep category matches + any high similarity items (>70%)
                                filteredMatches = fuzzyMatches.filter(m => 
                                    m.categoryMatch || m.similarity > 0.70
                                );
                            }
                            
                            if (filteredMatches.length > 0) {
                                // Store for user selection
                                needsMatching[name] = {
                                    item: item,
                                    matches: filteredMatches
                                };
                                matchStatus = 'needs-selection';
                            } else {
                                matchStatus = 'not-found';
                            }
                        } else {
                            matchStatus = 'not-found';
                        }
                    }
                    
                    // Store the matched ingredient with its standardized name
                    const standardizedName = masterMatch ? masterMatch.item : name;
                    matchedIngredients[name] = {
                        standardizedName: standardizedName,
                        masterData: masterMatch,
                        quantities: item.quantities,
                        isPantry: item.isPantry,
                        sources: item.sources,
                        matchStatus: matchStatus
                    };
                }

                // If there are items needing user selection, show modal
                if (Object.keys(needsMatching).length > 0) {
                    setPendingMatches(needsMatching);
                    setMatchSuggestions(Object.keys(needsMatching));
                    setShowMatchModal(true);
                    // Store matched ingredients for later consolidation
                    window.tempMatchedIngredients = matchedIngredients;
                    window.tempListStats = { listStats, totalInputItems };
                } else {
                    // No matching needed, proceed to consolidation
                    finalizeConsolidation(matchedIngredients, { listStats, totalInputItems });
                }
            }

            function finalizeConsolidation(matchedIngredients, stats) {
                // Step 2: Consolidate items with the same standardized name
                const consolidatedByStandardName = {};
                
                for (const [originalName, matchInfo] of Object.entries(matchedIngredients)) {
                    const stdName = matchInfo.standardizedName;
                    
                    if (!consolidatedByStandardName[stdName]) {
                        consolidatedByStandardName[stdName] = {
                            quantities: { ...matchInfo.quantities }, // Copy quantities from first occurrence
                            isPantry: matchInfo.isPantry,
                            sources: [...matchInfo.sources],
                            masterData: matchInfo.masterData,
                            matchStatus: matchInfo.matchStatus
                        };
                    } else {
                        // Merge quantities
                        const existing = consolidatedByStandardName[stdName];
                        for (const [unit, qty] of Object.entries(matchInfo.quantities)) {
                            if (!existing.quantities[unit]) {
                                existing.quantities[unit] = 0;
                            }
                            existing.quantities[unit] += qty;
                        }
                        // Merge sources
                        existing.sources = [...new Set([...existing.sources, ...matchInfo.sources])];
                        // Update pantry status
                        if (matchInfo.isPantry && !existing.isPantry) {
                            existing.isPantry = false; // If any instance has quantity, not pantry
                        }
                        // Keep best match status
                        if (matchInfo.matchStatus === 'exact') {
                            existing.matchStatus = 'exact';
                        }
                    }
                }

                // Step 3: Create final output
                const result = Object.entries(consolidatedByStandardName).map(([name, item]) => {
                    if (item.isPantry) {
                        return {
                            name: name,
                            count: 'pantry',
                            isPantry: true,
                            wasCombined: item.sources.length > 1,
                            defaultUnit: item.masterData?.defaultUnit || '',
                            preferredBrand: item.masterData?.preferredBrand || '',
                            category: item.masterData?.category || '',
                            preferredStore: item.masterData?.preferredStore || '',
                            altStore: item.masterData?.altStore || '',
                            matchStatus: item.matchStatus
                        };
                    }

                    const quantityStrings = Object.entries(item.quantities)
                        .map(([unit, qty]) => `${qty} ${unit}`);

                    return {
                        name: name,
                        count: quantityStrings.join(', '),
                        isPantry: false,
                        wasCombined: item.sources.length > 1,
                        defaultUnit: item.masterData?.defaultUnit || '',
                        preferredBrand: item.masterData?.preferredBrand || '',
                        category: item.masterData?.category || '',
                        preferredStore: item.masterData?.preferredStore || '',
                        altStore: item.masterData?.altStore || '',
                        matchStatus: item.matchStatus
                    };
                }).sort((a, b) => {
                    if (a.isPantry && !b.isPantry) return 1;
                    if (!a.isPantry && b.isPantry) return -1;
                    if (a.preferredStore !== b.preferredStore) {
                        return a.preferredStore.localeCompare(b.preferredStore);
                    }
                    return a.name.localeCompare(b.name);
                });

                setConsolidated(result);
                setSummary({
                    listStats: stats.listStats,
                    totalInputItems: stats.totalInputItems,
                    consolidatedCount: result.length,
                    itemsSaved: stats.totalInputItems - result.length
                });
            }

            function handleMatchSelection(ingredientName, selectedMatch) {
                // Update the temp matched ingredients with user selection
                if (window.tempMatchedIngredients) {
                    window.tempMatchedIngredients[ingredientName] = {
                        ...window.tempMatchedIngredients[ingredientName],
                        standardizedName: selectedMatch.item,
                        masterData: selectedMatch,
                        matchStatus: 'user-selected'
                    };
                }
                
                // Remove from pending
                const newPending = { ...pendingMatches };
                delete newPending[ingredientName];
                setPendingMatches(newPending);
                setMatchSuggestions(Object.keys(newPending));
                
                // If all matches resolved, finalize consolidation
                if (Object.keys(newPending).length === 0) {
                    setShowMatchModal(false);
                    if (window.tempMatchedIngredients && window.tempListStats) {
                        finalizeConsolidation(window.tempMatchedIngredients, window.tempListStats);
                        delete window.tempMatchedIngredients;
                        delete window.tempListStats;
                    }
                }
            }

            function skipMatch(ingredientName) {
                // Keep original name and mark as not-found
                if (window.tempMatchedIngredients) {
                    window.tempMatchedIngredients[ingredientName] = {
                        ...window.tempMatchedIngredients[ingredientName],
                        matchStatus: 'not-found'
                    };
                }
                
                const newPending = { ...pendingMatches };
                delete newPending[ingredientName];
                setPendingMatches(newPending);
                setMatchSuggestions(Object.keys(newPending));
                
                // If all matches resolved, finalize consolidation
                if (Object.keys(newPending).length === 0) {
                    setShowMatchModal(false);
                    if (window.tempMatchedIngredients && window.tempListStats) {
                        finalizeConsolidation(window.tempMatchedIngredients, window.tempListStats);
                        delete window.tempMatchedIngredients;
                        delete window.tempListStats;
                    }
                }
            }

            function copyToGoogleSheets() {
                const headers = ['Items', 'Units', 'Default Unit', 'Preferred Brand', 'Category', 'Preferred Store', 'Alt Store'];
                const rows = consolidated.map(item => [
                    item.name, 
                    item.count, 
                    item.defaultUnit, 
                    item.preferredBrand, 
                    item.category, 
                    item.preferredStore, 
                    item.altStore
                ]);
                const tsvContent = [headers, ...rows].map(row => row.join('\t')).join('\n');

                navigator.clipboard.writeText(tsvContent).then(() => {
                    setCopyStatus('âœ“ Copied! Paste into Google Sheets');
                    setTimeout(() => setCopyStatus(''), 3000);
                }).catch(() => {
                    setCopyStatus('Failed to copy');
                    setTimeout(() => setCopyStatus(''), 3000);
                });
            }

            function addNewList() {
                setLists([...lists, '']);
            }

            function removeList(index) {
                if (lists.length <= 1) return;
                const newLists = lists.filter((_, i) => i !== index);
                setLists(newLists);
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 py-8 px-4">
                    <div className="max-w-6xl mx-auto">
                        <div className="text-center mb-8">
                            <h1 className="text-4xl font-bold text-gray-800 mb-2">ðŸ›’ Ingredient List Consolidator</h1>
                            <p className="text-gray-600">Combine multiple ingredient lists with master data integration</p>
                        </div>

                        {/* Master Data Status */}
                        {masterData && (
                            <div className="bg-green-50 rounded-lg p-4 mb-6 border border-green-200">
                                <p className="text-green-800 font-semibold">
                                    âœ“ Loaded Master Data ({Object.keys(masterData.lookup).length} items)
                                </p>
                            </div>
                        )}
                        {!masterData && (
                            <div className="bg-yellow-50 rounded-lg p-4 mb-6 border border-yellow-200">
                                <p className="text-yellow-800 font-semibold">
                                    âš  Master data not loaded. Please configure API key in the code.
                                </p>
                            </div>
                        )}

                        {/* Input Lists */}
                        <div className="bg-white rounded-xl shadow-lg p-8 mb-6">
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                                {lists.map((list, index) => (
                                    <div key={index} className="relative">
                                        <div className="flex justify-between items-center mb-2">
                                            <label className="block text-sm font-semibold text-gray-700">
                                                List {index + 1}
                                            </label>
                                            {lists.length > 1 && (
                                                <button
                                                    onClick={() => removeList(index)}
                                                    className="text-red-500 hover:text-red-700 text-sm font-medium"
                                                >
                                                    Remove
                                                </button>
                                            )}
                                        </div>
                                        <textarea
                                            value={list}
                                            onChange={(e) => {
                                                const newLists = [...lists];
                                                newLists[index] = e.target.value;
                                                setLists(newLists);
                                            }}
                                            placeholder="Paste ingredients here (line-separated)..."
                                            className="w-full h-32 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                        />
                                    </div>
                                ))}
                            </div>

                            <div className="flex gap-3 justify-center">
                                <button
                                    onClick={addNewList}
                                    className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-colors"
                                >
                                    + Add Another List
                                </button>
                                <button
                                    onClick={consolidateIngredients}
                                    className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors"
                                    disabled={!masterData}
                                >
                                    Consolidate Lists
                                </button>
                            </div>
                        </div>

                        {/* Match Selection Modal */}
                        {showMatchModal && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                                <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6">
                                    <h2 className="text-2xl font-bold text-gray-800 mb-4">Select Matching Items</h2>
                                    <p className="text-gray-600 mb-6">
                                        Some ingredients don't have exact matches. Please select the best match or skip.
                                    </p>
                                    
                                    {matchSuggestions.map(ingredientName => (
                                        <div key={ingredientName} className="mb-6 p-4 border border-gray-200 rounded-lg">
                                            <h3 className="font-semibold text-lg text-gray-800 mb-3">
                                                "{ingredientName}"
                                            </h3>
                                            <div className="space-y-2">
                                                {pendingMatches[ingredientName].matches.map((match, idx) => (
                                                    <button
                                                        key={idx}
                                                        onClick={() => handleMatchSelection(ingredientName, match.data)}
                                                        className={`w-full text-left p-3 border rounded-lg transition-colors ${
                                                            match.categoryMatch 
                                                                ? 'border-blue-400 bg-blue-50 hover:bg-blue-100' 
                                                                : 'border-gray-300 hover:bg-gray-50'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between items-center">
                                                            <span className="font-medium">{match.data.item}</span>
                                                            <div className="flex items-center gap-2">
                                                                {match.categoryMatch && (
                                                                    <span className="text-xs bg-blue-200 text-blue-800 px-2 py-1 rounded">
                                                                        Category Match
                                                                    </span>
                                                                )}
                                                                <span className="text-sm text-gray-500">
                                                                    {Math.round(match.similarity * 100)}% match
                                                                </span>
                                                            </div>
                                                        </div>
                                                        <div className="text-sm text-gray-600 mt-1">
                                                            {match.data.category && `Category: ${match.data.category}`}
                                                            {match.data.preferredStore && ` â€¢ Store: ${match.data.preferredStore}`}
                                                        </div>
                                                    </button>
                                                ))}
                                                <button
                                                    onClick={() => skipMatch(ingredientName)}
                                                    className="w-full p-3 border border-gray-300 rounded-lg hover:bg-gray-50 text-gray-600 font-medium"
                                                >
                                                    Skip - Keep as "{ingredientName}"
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Summary Statistics */}
                        {summary && (
                            <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl shadow-lg p-6 mb-6 border border-blue-200">
                                <h2 className="text-xl font-bold text-gray-800 mb-4">ðŸ“Š Summary Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="bg-white rounded-lg p-4 shadow-sm">
                                        <h3 className="font-semibold text-gray-700 mb-3">Input Lists</h3>
                                        <div className="space-y-2">
                                            {summary.listStats.map((stat, index) => (
                                                <div key={index} className="flex justify-between items-center">
                                                    <span className="text-gray-600">List {stat.listNumber}:</span>
                                                    <span className="font-semibold text-blue-600">{stat.itemCount} items</span>
                                                </div>
                                            ))}
                                            <div className="border-t pt-2 mt-2 flex justify-between items-center">
                                                <span className="font-semibold text-gray-700">Total Input:</span>
                                                <span className="font-bold text-lg text-blue-700">{summary.totalInputItems} items</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div className="bg-white rounded-lg p-4 shadow-sm">
                                        <h3 className="font-semibold text-gray-700 mb-3">Consolidation Result</h3>
                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center">
                                                <span className="text-gray-600">Final List:</span>
                                                <span className="font-semibold text-green-600">{summary.consolidatedCount} items</span>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="text-gray-600">Items Combined:</span>
                                                <span className="font-semibold text-orange-600">{summary.itemsSaved} items</span>
                                            </div>
                                            <div className="border-t pt-2 mt-2">
                                                <div className="bg-green-100 rounded p-2 text-center">
                                                    <span className="text-green-800 font-semibold">
                                                        âœ“ Reduced by {summary.totalInputItems > 0 ? Math.round((summary.itemsSaved / summary.totalInputItems) * 100) : 0}%
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Results Table */}
                        {consolidated.length > 0 && (
                            <div className="bg-white rounded-xl shadow-lg p-8">
                                {hasConversions && (
                                    <div className="mb-4 text-xs text-gray-500 italic">
                                        Note: Cups have been converted to lbs (1 cup = 0.5 lbs)
                                    </div>
                                )}
                                <div className="flex justify-between items-center mb-6">
                                    <div>
                                        <h2 className="text-2xl font-bold text-gray-800">Shopping List</h2>
                                        <p className="text-sm text-gray-600 mt-1">
                                            <span className="inline-block w-4 h-4 bg-green-100 border border-green-300 mr-1"></span>
                                            Consolidated items
                                            <span className="inline-block w-4 h-4 bg-amber-50 border border-amber-300 ml-3 mr-1"></span>
                                            Pantry items
                                            <span className="inline-block w-4 h-4 bg-amber-200 border border-amber-400 ml-3 mr-1"></span>
                                            Combined pantry
                                            <span className="inline-block w-4 h-4 bg-red-100 border border-red-300 ml-3 mr-1"></span>
                                            Not found in master
                                        </p>
                                    </div>
                                    <div className="flex flex-col items-end gap-2">
                                        <button
                                            onClick={copyToGoogleSheets}
                                            className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-colors flex items-center gap-2"
                                        >
                                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                            </svg>
                                            Copy to Google Sheets
                                        </button>
                                        {copyStatus && (
                                            <span className={`text-sm font-medium ${copyStatus.includes('âœ“') ? 'text-green-600' : 'text-red-600'}`}>
                                                {copyStatus}
                                            </span>
                                        )}
                                    </div>
                                </div>
                                
                                <div className="overflow-x-auto">
                                    <table className="w-full border-collapse">
                                        <thead>
                                            <tr className="bg-gray-100">
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Items</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Units</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Default Unit</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Preferred Brand</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Category</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Preferred Store</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Alt Store</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {consolidated.map((item, index) => {
                                                let rowClass = "hover:bg-gray-50";
                                                
                                                if (item.matchStatus === 'not-found') {
                                                    rowClass = "bg-red-100 border-l-4 border-l-red-500";
                                                } else if (item.isPantry) {
                                                    if (item.wasCombined) {
                                                        rowClass = "bg-amber-200 border-l-4 border-l-amber-600";
                                                    } else {
                                                        rowClass = "bg-amber-50 border-l-4 border-l-amber-500";
                                                    }
                                                } else if (item.wasCombined) {
                                                    rowClass = "bg-green-100 border-l-4 border-l-green-500";
                                                }
                                                
                                                return (
                                                    <tr key={index} className={rowClass}>
                                                        <td className="border border-gray-300 px-4 py-2">{item.name}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.count}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.defaultUnit}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.preferredBrand}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.category}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.preferredStore}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.altStore}</td>
                                                    </tr>
                                                );
                                            })}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<IngredientConsolidator />, document.getElementById('root'));
    </script>
</body>
</html>
