<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ingredient List Consolidator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState } = React;

        function IngredientConsolidator() {
            const [lists, setLists] = useState(['', '', '']);
            const [consolidated, setConsolidated] = useState([]);
            const [copyStatus, setCopyStatus] = useState('');
            const [summary, setSummary] = useState(null);
            const [hasConversions, setHasConversions] = useState(false);

            function splitCommaDelimited(text) {
                // Split by commas and create individual lines
                return text.split(',').map(item => item.trim()).filter(item => item.length > 0).join('\n');
            }

            function parseQuantity(text) {
                const patterns = [
                    /(\d+\.?\d*)\s*(lbs?|pounds?)/gi,
                    /(\d+\.?\d*)\s*(oz|ounces?)/gi,
                    /(\d+\.?\d*)\s*(gallons?)/gi,
                    /(\d+\.?\d*)\s*(cups?)/gi,
                    /(\d+\.?\d*)\s*(packs?|packets?)/gi,
                    /(\d+\.?\d*)\s*(jars?)/gi,
                    /(\d+\.?\d*)\s*(bottles?)/gi,
                    /(\d+\.?\d*)\s*(blocks?)/gi,
                    /(\d+\.?\d*)\s*(boxes?)/gi,
                    /(\d+\.?\d*)\s*(bunches?)/gi,
                    /(\d+\.?\d*)\s*(cartons?)/gi,
                    /(\d+\.?\d*)\s*(stalks?)/gi,
                    /(\d+\.?\d*)\s*(cloves?)/gi,
                    /(\d+\.?\d*)\s*(count)/gi,
                    /(\d+\.?\d*)\s*(cans?)/gi,
                    /(\d+\.?\d*)\s*(tins?)/gi,
                    /(\d+\.?\d*)\s*(bags?)/gi,
                    /(\d+\.?\d*)\s*(sticks?)/gi,
                    /(\d+\.?\d*)\s*(gms?|grams?)/gi,
                ];

                // Find ALL matches and use the LAST one
                let lastMatch = null;
                let lastMatchIndex = -1;
                for (let pattern of patterns) {
                    const matches = [...text.matchAll(pattern)];
                    if (matches.length > 0) {
                        const match = matches[matches.length - 1];
                        if (match.index > lastMatchIndex) {
                            lastMatch = match;
                            lastMatchIndex = match.index;
                        }
                    }
                }

                if (lastMatch) {
                    let quantity = parseFloat(lastMatch[1]);
                    
                    // Check if there's a range before this number (e.g., "5-6 cups")
                    const beforeMatch = text.substring(0, lastMatch.index);
                    const rangeMatch = beforeMatch.match(/(\d+\.?\d*)\s*-\s*$/);
                    if (rangeMatch) {
                        // Use the upper limit (the number we already found)
                        quantity = parseFloat(lastMatch[1]);
                    }
                    
                    return { quantity: quantity, unit: lastMatch[2].toLowerCase() };
                }

                // If no unit found, look for the last standalone number (with potential range)
                const rangeMatch = text.match(/(\d+\.?\d*)\s*-\s*(\d+\.?\d*)/g);
                if (rangeMatch) {
                    const lastRange = rangeMatch[rangeMatch.length - 1];
                    const rangeParts = lastRange.match(/(\d+\.?\d*)\s*-\s*(\d+\.?\d*)/);
                    return { quantity: parseFloat(rangeParts[2]), unit: 'count' };
                }
                
                const allNumbers = [...text.matchAll(/(\d+\.?\d*)/g)];
                if (allNumbers.length > 0) {
                    const lastNumber = allNumbers[allNumbers.length - 1];
                    return { quantity: parseFloat(lastNumber[1]), unit: 'count' };
                }

                // No quantity found - mark as pantry item
                return { quantity: 0, unit: 'pantry' };
            }

            function normalizeUnit(unit, quantity) {
                // Convert cups to lbs (divide by 2)
                if (unit === 'cup' || unit === 'cups') {
                    return { unit: 'lbs', quantity: quantity / 2, converted: true };
                }
                
                const unitMap = {
                    'lb': 'lbs', 'pound': 'lbs', 'pounds': 'lbs',
                    'oz': 'oz', 'ounce': 'oz', 'ounces': 'oz',
                    'gallon': 'gallons',
                    'pack': 'packs', 'packet': 'packs', 'packets': 'packs',
                    'jar': 'jars', 'bottle': 'bottles', 'block': 'blocks',
                    'box': 'boxes', 'bunch': 'bunches', 'carton': 'cartons',
                    'stalk': 'stalks', 'clove': 'cloves',
                    'can': 'cans', 'cans': 'cans',
                    'tin': 'tins', 'tins': 'tins',
                    'bag': 'bags', 'bags': 'bags',
                    'stick': 'sticks', 'sticks': 'sticks',
                    'gm': 'gms', 'gms': 'gms', 'gram': 'gms', 'grams': 'gms',
                };
                return { unit: unitMap[unit] || unit, quantity: quantity, converted: false };
            }

            function normalizeIngredientName(name) {
                let normalized = name.toLowerCase().trim();
                
                // Remove dashes
                normalized = normalized.replace(/-/g, ' ');
                
                const isPepper = normalized.includes('pepper') && !normalized.includes('crushed') && !normalized.includes('flakes');
                const isBread = normalized.includes('bread') || normalized.includes('rice');
                
                const removeWords = [
                    'twin pack', 'costco', 'restaurant depot', 'trader joe',
                    'organic', 'extra virgin', 'virgin', 'unsalted', 'salted',
                    'fresh', 'frozen', 'canned',
                    'shredded', 'diced', 'chopped', 'sliced', 'whole', 'peeled',
                    'flat leaf', 'baby', 'purÃ©e', 'puree', 'pantry',
                    '\\(.*?\\)'
                ];
                
                if (!isPepper && !isBread) {
                    removeWords.push('red', 'green', 'yellow', 'white', 'black', 'purple');
                }
                
                removeWords.forEach(word => {
                    const regex = new RegExp('\\b' + word + '\\b', 'gi');
                    normalized = normalized.replace(regex, '');
                });
                
                normalized = normalized.replace(/\s+/g, ' ').trim();
                
                // Remove trailing hyphens, en-dashes, and em-dashes
                normalized = normalized.replace(/[-â€“â€”]+$/, '').trim();
                
                // Handle "garlic cloves" -> "garlic"
                normalized = normalized.replace(/\bgarlic\s+clove[s]?\b/gi, 'garlic');
                
                const pluralMap = {
                    'tomatoes': 'tomato', 'potatoes': 'potato', 'onions': 'onion',
                    'carrots': 'carrot', 'peppers': 'pepper',
                    'chilies': 'chili', 'chillies': 'chili',
                    'lemons': 'lemon', 'limes': 'lime',
                    'leaves': 'leaf', 'bunches': 'bunch',
                };
                
                for (let [plural, singular] of Object.entries(pluralMap)) {
                    const regex = new RegExp('\\b' + plural + '\\b', 'gi');
                    normalized = normalized.replace(regex, singular);
                }
                
                return normalized;
            }

            function parseIngredientLine(line) {
                line = line.replace(/[\u2060\u200B\u200C\u200D\uFEFF]/g, '');
                line = line.trim();
                if (!line) return null;
                
                // Remove bullet point formatting from the beginning
                line = line.replace(/^[â€¢\-\*]\s*/, '');  // Remove â€¢, -, * bullets
                line = line.replace(/^\d+[\.)]\s*/, '');  // Remove numbered lists like "1." or "1)"
                line = line.trim();

                const parsed = parseQuantity(line);
                
                // Remove the quantity and unit from the line to get the ingredient name
                let ingredientName = line;
                
                if (parsed.quantity > 0) {
                    // Find and remove only the LAST occurrence of number+unit (including ranges)
                    const unitPattern = /(\d+\.?\d*\s*-\s*)?(\d+\.?\d*)\s*(lbs?|pounds?|oz|ounces?|gallons?|cups?|packs?|packets?|jars?|bottles?|blocks?|boxes?|bunches?|cartons?|stalks?|cloves?|count|cans?|tins?|bags?|sticks?|gms?|grams?)\b/gi;
                    const matches = [...line.matchAll(unitPattern)];
                    
                    if (matches.length > 0) {
                        const lastMatch = matches[matches.length - 1];
                        const beforeMatch = line.substring(0, lastMatch.index);
                        const afterMatch = line.substring(lastMatch.index + lastMatch[0].length);
                        ingredientName = (beforeMatch + afterMatch).trim();
                    } else {
                        // No unit found, just remove the last standalone number or range
                        const rangeMatches = [...line.matchAll(/(\d+\.?\d*)\s*-\s*(\d+\.?\d*)/g)];
                        if (rangeMatches.length > 0) {
                            const lastRangeMatch = rangeMatches[rangeMatches.length - 1];
                            const beforeRange = line.substring(0, lastRangeMatch.index);
                            const afterRange = line.substring(lastRangeMatch.index + lastRangeMatch[0].length);
                            ingredientName = (beforeRange + afterRange).trim();
                        } else {
                            const numberMatches = [...line.matchAll(/(\d+\.?\d*)/g)];
                            if (numberMatches.length > 0) {
                                const lastNumMatch = numberMatches[numberMatches.length - 1];
                                const beforeNum = line.substring(0, lastNumMatch.index);
                                const afterNum = line.substring(lastNumMatch.index + lastNumMatch[0].length);
                                ingredientName = (beforeNum + afterNum).trim();
                            }
                        }
                    }
                }

                ingredientName = normalizeIngredientName(ingredientName);
                
                // Skip if we couldn't extract an ingredient name
                if (!ingredientName || ingredientName.length === 0) {
                    return null;
                }

                const normalized = normalizeUnit(parsed.unit, parsed.quantity);

                return {
                    normalized: ingredientName,
                    quantity: normalized.quantity,
                    unit: normalized.unit,
                    isPantry: parsed.unit === 'pantry',
                    converted: normalized.converted
                };
            }

            function consolidateIngredients() {
                const allIngredients = {};
                const listStats = [];
                let totalInputItems = 0;
                let conversionsDetected = false;

                lists.forEach((list, listIndex) => {
                    if (!list.trim()) return;

                    let itemCount = 0;
                    const lines = list.split('\n');
                    
                    lines.forEach(line => {
                        const ingredient = parseIngredientLine(line);
                        if (!ingredient) return;

                        itemCount++;
                        totalInputItems++;
                        
                        if (ingredient.converted) {
                            conversionsDetected = true;
                        }

                        if (!allIngredients[ingredient.normalized]) {
                            allIngredients[ingredient.normalized] = {
                                quantities: {},
                                isPantry: ingredient.isPantry,
                                sources: []
                            };
                        }

                        const entry = allIngredients[ingredient.normalized];
                        
                        // If this is a pantry item, mark it
                        if (ingredient.isPantry) {
                            entry.isPantry = true;
                        } else {
                            // Only add quantities if it's not a pantry item
                            if (!entry.quantities[ingredient.unit]) {
                                entry.quantities[ingredient.unit] = 0;
                            }
                            entry.quantities[ingredient.unit] += ingredient.quantity;
                            entry.isPantry = false; // Override pantry status if we have actual quantities
                        }
                        
                        entry.sources.push(listIndex + 1);
                    });

                    if (itemCount > 0) {
                        listStats.push({
                            listNumber: listIndex + 1,
                            itemCount: itemCount
                        });
                    }
                });

                setHasConversions(conversionsDetected);

                const result = Object.keys(allIngredients)
                    .sort()
                    .map(name => {
                        const item = allIngredients[name];
                        
                        if (item.isPantry) {
                            return {
                                name: name,
                                count: 'pantry',
                                isPantry: true,
                                wasCombined: item.sources.length > 1
                            };
                        }

                        const quantityStrings = Object.entries(item.quantities)
                            .map(([unit, qty]) => {
                                return `${qty} ${unit}`;
                            });

                        return {
                            name: name,
                            count: quantityStrings.join(', '),
                            isPantry: false,
                            wasCombined: item.sources.length > 1
                        };
                    })
                    .sort((a, b) => {
                        // Sort pantry items to the bottom
                        if (a.isPantry && !b.isPantry) return 1;
                        if (!a.isPantry && b.isPantry) return -1;
                        return a.name.localeCompare(b.name);
                    });

                setConsolidated(result);
                setSummary({
                    listStats: listStats,
                    totalInputItems: totalInputItems,
                    consolidatedCount: result.length,
                    itemsSaved: totalInputItems - result.length
                });
            }

            function copyToGoogleSheets() {
                const headers = ['Items', 'Units'];
                const rows = consolidated.map(item => [item.name, item.count]);
                const tsvContent = [headers, ...rows].map(row => row.join('\t')).join('\n');

                navigator.clipboard.writeText(tsvContent).then(() => {
                    setCopyStatus('âœ“ Copied! Paste into Google Sheets');
                    setTimeout(() => setCopyStatus(''), 3000);
                }).catch(() => {
                    setCopyStatus('Failed to copy');
                    setTimeout(() => setCopyStatus(''), 3000);
                });
            }

            function addNewList() {
                setLists([...lists, '']);
            }

            function removeList(index) {
                if (lists.length <= 1) return;
                const newLists = lists.filter((_, i) => i !== index);
                setLists(newLists);
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 py-8 px-4">
                    <div className="max-w-6xl mx-auto">
                        <div className="text-center mb-8">
                            <h1 className="text-4xl font-bold text-gray-800 mb-2">ðŸ›’ Ingredient List Consolidator</h1>
                            <p className="text-gray-600">Combine multiple ingredient lists into one organized shopping list</p>
                        </div>

                        <div className="bg-white rounded-xl shadow-lg p-8 mb-6">
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                                {lists.map((list, index) => (
                                    <div key={index} className="relative">
                                        <div className="flex justify-between items-center mb-2">
                                            <label className="block text-sm font-semibold text-gray-700">
                                                List {index + 1}
                                            </label>
                                            {lists.length > 1 && (
                                                <button
                                                    onClick={() => removeList(index)}
                                                    className="text-red-500 hover:text-red-700 text-sm font-medium"
                                                >
                                                    Remove
                                                </button>
                                            )}
                                        </div>
                                        <textarea
                                            value={list}
                                            onChange={(e) => {
                                                const newLists = [...lists];
                                                newLists[index] = e.target.value;
                                                setLists(newLists);
                                            }}
                                            placeholder="Paste ingredients here (comma-separated or line-separated)..."
                                            className="w-full h-32 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                        />
                                    </div>
                                ))}
                            </div>

                            <div className="flex gap-3 justify-center">
                                <button
                                    onClick={addNewList}
                                    className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-colors"
                                >
                                    + Add Another List
                                </button>
                                <button
                                    onClick={consolidateIngredients}
                                    className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors"
                                >
                                    Consolidate Lists
                                </button>
                            </div>
                        </div>

                        {summary && (
                            <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl shadow-lg p-6 mb-6 border border-blue-200">
                                <h2 className="text-xl font-bold text-gray-800 mb-4">ðŸ“Š Summary Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="bg-white rounded-lg p-4 shadow-sm">
                                        <h3 className="font-semibold text-gray-700 mb-3">Input Lists</h3>
                                        <div className="space-y-2">
                                            {summary.listStats.map((stat, index) => (
                                                <div key={index} className="flex justify-between items-center">
                                                    <span className="text-gray-600">List {stat.listNumber}:</span>
                                                    <span className="font-semibold text-blue-600">{stat.itemCount} items</span>
                                                </div>
                                            ))}
                                            <div className="border-t pt-2 mt-2 flex justify-between items-center">
                                                <span className="font-semibold text-gray-700">Total Input:</span>
                                                <span className="font-bold text-lg text-blue-700">{summary.totalInputItems} items</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div className="bg-white rounded-lg p-4 shadow-sm">
                                        <h3 className="font-semibold text-gray-700 mb-3">Consolidation Result</h3>
                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center">
                                                <span className="text-gray-600">Final List:</span>
                                                <span className="font-semibold text-green-600">{summary.consolidatedCount} items</span>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="text-gray-600">Items Combined:</span>
                                                <span className="font-semibold text-orange-600">{summary.itemsSaved} items</span>
                                            </div>
                                            <div className="border-t pt-2 mt-2">
                                                <div className="bg-green-100 rounded p-2 text-center">
                                                    <span className="text-green-800 font-semibold">
                                                        âœ“ Reduced by {summary.totalInputItems > 0 ? Math.round((summary.itemsSaved / summary.totalInputItems) * 100) : 0}%
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {consolidated.length > 0 && (
                            <div className="bg-white rounded-xl shadow-lg p-8">
                                {hasConversions && (
                                    <div className="mb-4 text-xs text-gray-500 italic">
                                        Note: Cups have been converted to lbs (1 cup = 0.5 lbs)
                                    </div>
                                )}
                                <div className="flex justify-between items-center mb-6">
                                    <div>
                                        <h2 className="text-2xl font-bold text-gray-800">Shopping List</h2>
                                        <p className="text-sm text-gray-600 mt-1">
                                            <span className="inline-block w-4 h-4 bg-green-100 border border-green-300 mr-1"></span>
                                            Consolidated items
                                            <span className="inline-block w-4 h-4 bg-amber-50 border border-amber-300 ml-3 mr-1"></span>
                                            Pantry items
                                        </p>
                                    </div>
                                    <div className="flex flex-col items-end gap-2">
                                        <button
                                            onClick={copyToGoogleSheets}
                                            className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-colors flex items-center gap-2"
                                        >
                                            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                            </svg>
                                            Copy to Google Sheets
                                        </button>
                                        {copyStatus && (
                                            <span className={`text-sm font-medium ${copyStatus.includes('âœ“') ? 'text-green-600' : 'text-red-600'}`}>
                                                {copyStatus}
                                            </span>
                                        )}
                                    </div>
                                </div>
                                
                                <table className="w-full border-collapse">
                                    <thead>
                                        <tr className="bg-gray-100">
                                            <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Items</th>
                                            <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Units</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        {consolidated.map((item, index) => {
                                            let rowClass = "hover:bg-gray-50";
                                            if (item.isPantry) {
                                                rowClass = "bg-amber-50 border-l-4 border-l-amber-500";
                                            } else if (item.wasCombined) {
                                                rowClass = "bg-green-100 border-l-4 border-l-green-500";
                                            }
                                            return (
                                                <tr key={index} className={rowClass}>
                                                    <td className="border border-gray-300 px-4 py-2">{item.name}</td>
                                                    <td className="border border-gray-300 px-4 py-2">{item.count}</td>
                                                </tr>
                                            );
                                        })}
                                    </tbody>
                                </table>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<IngredientConsolidator />, document.getElementById('root'));
    </script>
</body>
</html>
