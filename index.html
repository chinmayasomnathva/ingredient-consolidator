<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ingredient List Consolidator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        function IngredientConsolidator() {
            const [lists, setLists] = useState(['', '', '']);
            const [consolidated, setConsolidated] = useState([]);
            const [copyStatus, setCopyStatus] = useState('');
            const [submitStatus, setSubmitStatus] = useState('');
            const [summary, setSummary] = useState(null);
            const [hasConversions, setHasConversions] = useState(false);
            const [apiKey, setApiKey] = useState(localStorage.getItem('googleSheetsApiKey') || '');
            const [masterData, setMasterData] = useState(null);
            const [loadingMaster, setLoadingMaster] = useState(false);
            const [masterError, setMasterError] = useState('');
            const [matchSuggestions, setMatchSuggestions] = useState([]);
            const [showMatchModal, setShowMatchModal] = useState(false);
            const [pendingMatches, setPendingMatches] = useState({});
            const [oauthToken, setOauthToken] = useState(null);
            const [oauthUser, setOauthUser] = useState('');
            const [submitDay, setSubmitDay] = useState('friday');

            const SHEET_ID = '1yJyhd23X77zH_ITtQu1AtNTI-Ak9KnorymsPJgEJKMc';
            const SHEET_NAME = 'Master List_Annapurna'; // Adjust if needed
            const API_KEY = 'AIzaSyAxFgijOuH0PeE-wmK3DBG2XqmHNnnabyE'; // Set your Google Sheets API key here
            // OAuth Client ID — create at console.cloud.google.com → APIs & Services → Credentials
            // Add this page's origin as an Authorised JavaScript Origin
            const OAUTH_CLIENT_ID = '905820431932-rpieibglpo732pk1ia56bo9mub4b3qtk.apps.googleusercontent.com';
            

            // Load master data on mount if API key is set
            useEffect(() => {
                if (API_KEY) {
                    setApiKey(API_KEY);
                }
            }, []);

            // Load master data when API key changes
            useEffect(() => {
                if (apiKey) {
                    loadMasterData();
                }
            }, [apiKey]);

            async function loadMasterData() {
                setLoadingMaster(true);
                setMasterError('');
                
                try {
                    const range = `${SHEET_NAME}!A:F`; // Items, Default Unit, Preferred Brand, Category, Preferred Store, Alt Store
                    const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values/Master_Items?key=${apiKey}`;
                    
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error('Failed to fetch master data. Check your API key.');
                    }
                    
                    const data = await response.json();
                    const rows = data.values || [];
                    
                    // Skip header row, create master lookup with category grouping
                    const masterLookup = {};
                    const categoryIndex = {};
                    
                    for (let i = 1; i < rows.length; i++) {
                        const [item, defaultUnit, preferredBrand, category, preferredStore, altStore] = rows[i];
                        if (item) {
                            const itemLower = item.toLowerCase().trim();
                            const categoryLower = (category || '').toLowerCase().trim();
                            
                            masterLookup[itemLower] = {
                                item: item,
                                defaultUnit: defaultUnit || '',
                                preferredBrand: preferredBrand || '',
                                category: category || '',
                                preferredStore: preferredStore || '',
                                altStore: altStore || ''
                            };
                            
                            // Build category index for context-aware matching
                            if (categoryLower) {
                                if (!categoryIndex[categoryLower]) {
                                    categoryIndex[categoryLower] = [];
                                }
                                categoryIndex[categoryLower].push({
                                    key: itemLower,
                                    data: masterLookup[itemLower]
                                });
                            }
                        }
                    }
                    
                    setMasterData({ lookup: masterLookup, categoryIndex: categoryIndex });
                    setLoadingMaster(false);
                } catch (error) {
                    setMasterError(error.message);
                    setLoadingMaster(false);
                }
            }

            function saveApiKey() {
                localStorage.setItem('googleSheetsApiKey', apiKey);
                loadMasterData();
            }

            // Enhanced fuzzy matching with category context and synonym support
            function fuzzyMatchWithCategory(input, masterData, threshold = 0.5) {
                const inputLower = input.toLowerCase();
                const { lookup, categoryIndex } = masterData;
                const matches = [];
                
                // Synonym mapping for common ingredient variations
                const synonyms = {
                    'jira': 'cumin',
                    'jeera': 'cumin',
                    'zeera': 'cumin',
                    'coriander': 'cilantro',
                    'coriander leaf': 'cilantro',
                    'curry leaf': 'curry leaves',
                    'tomato': 'tomatoes',
                    'chickpea': 'garbanzo beans',
                    'chickpeas': 'garbanzo beans',
                    'garbanzo': 'garbanzo beans',
                    'garbanzos': 'garbanzo beans',
                    'english cucumber': 'cucumbers english long',
                    'cucumber': 'cucumbers',
                    'penne pasta': 'pasta penne rigatoni elbow',
                    'penne': 'pasta penne',
                    'rigatoni': 'pasta penne',
                    'elbow pasta': 'pasta penne rigatoni elbow',
                    'mixed bell pepper': 'bell peppers mixed',
                    'bell pepper': 'bell peppers',
                    'butter sticks': 'unsalted butter sticks',
                    'butter': 'unsalted butter sticks',
                    'peanut butter': 'peanut butter',
                    'almond butter': 'almond butter',
                    'nut butter': 'nut butter'
                };
                
                // Check if input has a known synonym — prefer longest matching key
                let searchTerm = inputLower;
                let bestSynonymKey = '';
                for (const [key, value] of Object.entries(synonyms)) {
                    if (inputLower.includes(key) && key.length > bestSynonymKey.length) {
                        bestSynonymKey = key;
                        searchTerm = inputLower.replace(key, value);
                    }
                }
                
                // Strip parenthetical content from searchTerm
                // e.g. "jira (cumin)" after synonym substitution → "cumin (cumin)" → "cumin"
                searchTerm = searchTerm.replace(/\([^)]+\)/g, '').replace(/\s+/g, ' ').trim();

                console.log('[MATCH] input:', inputLower, '=> searchTerm:', searchTerm);
                // Extract main noun (last word) and adjectives (other words)
                const inputWords = searchTerm.split(/\s+/);
                const inputNoun = inputWords[inputWords.length - 1]; // e.g., "chana" from "black chana"
                const inputAdjectives = inputWords.slice(0, -1); // e.g., ["black"] from "black chana"
                
                // First pass: Look for matches and determine likely category
                let likelyCategory = null;
                let maxInitialSimilarity = 0;
                
                for (const [key, data] of Object.entries(lookup)) {
                    const keyForMatch = key
                        .replace(/\(([^)]+)\)/g, (_, inner) => ' ' + inner.replace(/[-–]/g, ' '))
                        .replace(/\s+/g, ' ').trim();
                    const similarity = calculateSimilarity(searchTerm, keyForMatch);
                    if (similarity > maxInitialSimilarity) {
                        maxInitialSimilarity = similarity;
                        likelyCategory = data.category.toLowerCase();
                    }
                }
                
                // Second pass: Score matches with category boost and noun-based matching
                for (const [key, data] of Object.entries(lookup)) {
                    // Strip parenthetical content from master key for matching
                    // e.g. "cucumbers (english - long)" → "cucumbers english long"
                    // e.g. "bell peppers (mixed)" → "bell peppers mixed"
                    const keyForMatch = key
                        .replace(/\(([^)]+)\)/g, (_, inner) => ' ' + inner.replace(/[-–]/g, ' '))
                        .replace(/\s+/g, ' ').trim();
                    let similarity = calculateSimilarity(searchTerm, keyForMatch);
                    
                    // BLOCKLIST: Prevent compound masala/spice blends from matching simple ingredients
                    // e.g., "Kanda Lasun Masala (Onion Garlic)" should NOT match "onion" or "garlic"
                    const compoundMasalaPattern = /\b(masala|blend|spice mix|seasoning)\b/i;
                    const isCompoundMasala = compoundMasalaPattern.test(key);
                    const inputIsSimple = searchTerm.split(/\s+/).length <= 2;
                    if (isCompoundMasala && inputIsSimple) {
                        // Only allow if the input itself contains "masala" or "spice"
                        if (!/(masala|spice|seasoning|blend)/i.test(searchTerm)) {
                            continue; // Skip this match entirely
                        }
                    }
                    
                    // Boost matches that contain the main noun
                    const masterWords = key.split(/\s+/);
                    const masterNoun = masterWords[masterWords.length - 1];
                    
                    // If master item contains the input noun, boost similarity
                    if (keyForMatch.includes(inputNoun)) {
                        similarity = Math.min(1.0, similarity * 1.2); // 20% boost for noun match
                    }
                    
                    // Boost similarity if in the same category as the likely match
                    if (likelyCategory && data.category.toLowerCase() === likelyCategory) {
                        similarity = Math.min(1.0, similarity * 1.3); // 30% boost for same category
                    }
                    
                    if (similarity >= threshold) {
                        matches.push({ 
                            key, 
                            data, 
                            similarity,
                            categoryMatch: data.category.toLowerCase() === likelyCategory,
                            nounMatch: keyForMatch.includes(inputNoun)
                        });
                    }
                }
                
                // Sort by: noun match first, then similarity, then category match
                return matches.sort((a, b) => {
                    // Prioritize noun matches
                    if (a.nounMatch && !b.nounMatch) return -1;
                    if (!a.nounMatch && b.nounMatch) return 1;
                    
                    // Then by similarity
                    if (Math.abs(a.similarity - b.similarity) > 0.05) {
                        return b.similarity - a.similarity;
                    }
                    
                    // Then by category match
                    if (a.categoryMatch && !b.categoryMatch) return -1;
                    if (!a.categoryMatch && b.categoryMatch) return 1;
                    
                    return 0;
                }).slice(0, 8); // Show up to 8 matches
            }

            // Simple similarity calculation (Levenshtein-inspired)
            function calculateSimilarity(str1, str2) {
                const longer = str1.length > str2.length ? str1 : str2;
                const shorter = str1.length > str2.length ? str2 : str1;
                
                if (longer.length === 0) return 1.0;
                
                // Handle common singular/plural variations
                const singularToPlural = {
                    'tomato': 'tomatoes', 'potato': 'potatoes', 'leaf': 'leaves', 'leaves': 'leaves',
                    'pepper': 'peppers', 'cucumber': 'cucumbers', 'bean': 'beans',
                    'onion': 'onions', 'carrot': 'carrots', 'lemon': 'lemons'
                };
                const pluralToSingular = {
                    'tomatoes': 'tomato', 'potatoes': 'potato', 'leaves': 'leaf',
                    'peppers': 'pepper', 'cucumbers': 'cucumber', 'beans': 'bean',
                    'onions': 'onion', 'carrots': 'carrot', 'lemons': 'lemon'
                };
                
                // Check if one is singular and other is plural of same word
                if (singularToPlural[shorter] === longer || pluralToSingular[shorter] === longer ||
                    singularToPlural[longer] === shorter || pluralToSingular[longer] === shorter) {
                    return 0.95; // High similarity for singular/plural pairs
                }
                
                // Split into words for analysis
                const shorterWords = shorter.split(/\s+/);
                const longerWords = longer.split(/\s+/);
                
                // Check for word overlap - at least one main word should match
                const commonWords = shorterWords.filter(word => 
                    longerWords.some(lw => {
                        // Also check singular/plural forms
                        return lw.includes(word) || word.includes(lw) || 
                               singularToPlural[word] === lw || pluralToSingular[word] === lw ||
                               singularToPlural[lw] === word || pluralToSingular[lw] === word;
                    })
                );
                
                // If no common words at all, very low similarity
                if (commonWords.length === 0) {
                    return 0.3;
                }
                
                // Check if shorter is contained in longer
                if (longer.includes(shorter)) {
                    // If input (shorter) is a complete word match in master (longer)
                    
                    // If input is single word and master has multiple words
                    if (shorterWords.length === 1 && longerWords.length > 1) {
                        // Check if the single word is an exact match to one of the words (or singular/plural)
                        const exactWordMatch = longerWords.some(word => {
                            return word === shorter || 
                                   singularToPlural[shorter] === word || 
                                   pluralToSingular[shorter] === word;
                        });
                        
                        if (exactWordMatch) {
                            // Check if other words are descriptors
                            const otherWords = longerWords.filter(word => 
                                word !== shorter && 
                                singularToPlural[shorter] !== word && 
                                pluralToSingular[shorter] !== word
                            );
                            const descriptors = ['frozen', 'fresh', 'canned', 'dried', 'raw', 'cooked', 
                                               'baby', 'red', 'white', 'green', 'yellow', 'black', 
                                               'organic', 'large', 'small', 'whole', 'chopped', 'diced',
                                               'sliced', 'ground', 'big', 'packet', 'pack', 'bundle',
                                               'loose', 'extra', 'mixed', 'english', 'long', 'mini',
                                               'seedless', 'boneless', 'skinless', 'shelled', 'pitted'];
                            const hasOnlyDescriptors = otherWords.every(word => descriptors.includes(word.toLowerCase()));
                            
                            if (hasOnlyDescriptors) {
                                // "spinach" → "baby spinach" or "onion" → "red onion"
                                return 0.80; // High enough to show in resolution but not auto-match
                            } else {
                                // "potato" → "potato chips" (chips is not a descriptor)
                                return 0.60;
                            }
                        } else {
                            return 0.5;
                        }
                    }
                    
                    // If word counts are the same or similar, high score
                    if (Math.abs(shorterWords.length - longerWords.length) <= 1) {
                        return 0.9;
                    }
                    
                    return 0.8;
                }
                
                // Word-overlap based scoring (order-independent)
                // Handles cases like "english cucumbers" vs "cucumbers english long"
                const allInputWords = shorter.split(/\s+/).filter(w => w.length > 1);
                const allMasterWords = longer.split(/\s+/).filter(w => w.length > 1);
                const descriptorSet = new Set(['frozen','fresh','canned','dried','raw','cooked',
                    'baby','red','white','green','yellow','black','organic','large','small','whole',
                    'chopped','diced','sliced','ground','big','packet','pack','bundle','loose','extra',
                    'mixed','english','long','mini','seedless','boneless','skinless','shelled','pitted']);

                // Count how many input words appear in master words (with s/plural tolerance)
                let matchedInputWords = 0;
                allInputWords.forEach(iw => {
                    if (allMasterWords.some(mw =>
                        mw === iw || mw.includes(iw) || iw.includes(mw) ||
                        singularToPlural[iw] === mw || pluralToSingular[iw] === mw ||
                        singularToPlural[mw] === iw || pluralToSingular[mw] === iw
                    )) matchedInputWords++;
                });

                const inputCoverage = matchedInputWords / allInputWords.length;

                // All input words matched in master → good match, check if extra master words are descriptors
                if (inputCoverage === 1.0) {
                    const extraMasterWords = allMasterWords.filter(mw =>
                        !allInputWords.some(iw =>
                            mw === iw || mw.includes(iw) || iw.includes(mw) ||
                            singularToPlural[iw] === mw || pluralToSingular[iw] === mw
                        )
                    );
                    const allExtrasAreDescriptors = extraMasterWords.every(w => descriptorSet.has(w));
                    if (allExtrasAreDescriptors) return 0.85;
                    return 0.70;
                }

                // Most input words matched → decent match
                if (inputCoverage >= 0.66) return 0.60;

                // Calculate edit distance as fallback
                const editDistance = levenshteinDistance(str1, str2);
                return (longer.length - editDistance) / longer.length;
            }

            function levenshteinDistance(str1, str2) {
                const matrix = [];
                
                for (let i = 0; i <= str2.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= str1.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= str2.length; i++) {
                    for (let j = 1; j <= str1.length; j++) {
                        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[str2.length][str1.length];
            }

            function parseQuantity(text) {
                const patterns = [
                    /(\d*\.?\d+)\s*(lbs?|pounds?)/gi,
                    /(\d*\.?\d+)\s*(oz|ounces?)/gi,
                    /(\d*\.?\d+)\s*(gallons?)/gi,
                    /(\d*\.?\d+)\s*(cups?)/gi,
                    /(\d*\.?\d+)\s*(packs?|packets?)/gi,
                    /(\d*\.?\d+)\s*(jars?)/gi,
                    /(\d*\.?\d+)\s*(bottles?)/gi,
                    /(\d*\.?\d+)\s*(blocks?)/gi,
                    /(\d*\.?\d+)\s*(boxes?)/gi,
                    /(\d*\.?\d+)\s*(bunches?)/gi,
                    /(\d*\.?\d+)\s*(cartons?)/gi,
                    /(\d*\.?\d+)\s*(stalks?)/gi,
                    /(\d*\.?\d+)\s*(cloves?)/gi,
                    /(\d*\.?\d+)\s*(count)/gi,
                    /(\d*\.?\d+)\s*(cans?)/gi,
                    /(\d*\.?\d+)\s*(tins?)/gi,
                    /(\d*\.?\d+)\s*(bags?)/gi,
                    /(\d*\.?\d+)\s*(sticks?)/gi,
                    /(\d*\.?\d+)\s*(gms?|grams?)/gi,
                ];

                let lastMatch = null;
                let lastMatchIndex = -1;
                for (let pattern of patterns) {
                    const matches = [...text.matchAll(pattern)];
                    if (matches.length > 0) {
                        const match = matches[matches.length - 1];
                        if (match.index > lastMatchIndex) {
                            lastMatch = match;
                            lastMatchIndex = match.index;
                        }
                    }
                }

                if (lastMatch) {
                    let quantity = parseFloat(lastMatch[1]);
                    const beforeMatch = text.substring(0, lastMatch.index);
                    const rangeMatch = beforeMatch.match(/(\d+\.?\d*)\s*-\s*$/);
                    if (rangeMatch) {
                        quantity = parseFloat(lastMatch[1]);
                    }
                    return { quantity: quantity, unit: lastMatch[2].toLowerCase() };
                }

                const rangeMatch = text.match(/(\d*\.?\d+)\s*-\s*(\d*\.?\d+)/g);
                if (rangeMatch) {
                    const lastRange = rangeMatch[rangeMatch.length - 1];
                    const rangeParts = lastRange.match(/(\d*\.?\d+)\s*-\s*(\d*\.?\d+)/);
                    return { quantity: parseFloat(rangeParts[2]), unit: 'count' };
                }
                
                const allNumbers = [...text.matchAll(/(\d*\.?\d+)/g)];
                if (allNumbers.length > 0) {
                    const lastNumber = allNumbers[allNumbers.length - 1];
                    return { quantity: parseFloat(lastNumber[1]), unit: 'count' };
                }

                return { quantity: 0, unit: 'pantry' };
            }

            function normalizeUnit(unit, quantity) {
                if (unit === 'cup' || unit === 'cups') {
                    return { unit: 'lbs', quantity: quantity / 2, converted: true };
                }
                
                const unitMap = {
                    'lb': 'lbs', 'pound': 'lbs', 'pounds': 'lbs',
                    'oz': 'oz', 'ounce': 'oz', 'ounces': 'oz',
                    'gallon': 'gallons',
                    'pack': 'packs', 'packet': 'packs', 'packets': 'packs',
                    'jar': 'jars', 'bottle': 'bottles', 'block': 'blocks',
                    'box': 'boxes', 'bunch': 'bunches', 'carton': 'cartons',
                    'stalk': 'stalks', 'clove': 'cloves',
                    'can': 'cans', 'cans': 'cans',
                    'tin': 'tins', 'tins': 'tins',
                    'bag': 'bags', 'bags': 'bags',
                    'stick': 'sticks', 'sticks': 'sticks',
                    'gm': 'gms', 'gms': 'gms', 'gram': 'gms', 'grams': 'gms',
                };
                return { unit: unitMap[unit] || unit, quantity: quantity, converted: false };
            }

            function normalizeIngredientName(name) {
                let normalized = name.toLowerCase().trim();
                normalized = normalized.replace(/-/g, ' ');
                
                const isPepper = normalized.includes('pepper') && !normalized.includes('crushed') && !normalized.includes('flakes');
                const isBread = normalized.includes('bread') || normalized.includes('rice');
                const isChili = normalized.includes('chili') || normalized.includes('chilli');
                const isApple = normalized.includes('apple');
                const isOnion = normalized.includes('onion');
                const isTomato = normalized.includes('tomato');
                const isBellPepper = normalized.includes('bell');
                const isPeas = normalized.includes('peas') || normalized.includes('vatana');
                const isPumpkin = normalized.includes('pumpkin') || normalized.includes('guard');
                const isCucumber = normalized.includes('cucumber');
                const isBean = normalized.includes('bean') || normalized.includes('chickpea') || normalized.includes('garbanzo');
                
                const removeWords = [
                    'twin pack', 'costco', 'restaurant depot', 'trader joe',
                    'organic', 'extra virgin', 'virgin', 'unsalted', 'salted',
                    'fresh', 'frozen', 'canned',
                    'shredded', 'diced', 'chopped', 'sliced', 'whole', 'peeled',
                    'flat leaf', 'baby', 'purée', 'puree', 'pantry',
                    'big', 'large', 'small', 'packet', 'pack', 'bundle',
                    'mixed', 'english', 'long', 'mini', 'seedless', 'boneless', 'skinless'
                ];
                
                if (!isPepper && !isBread && !isChili && !isApple && !isOnion && !isTomato && !isBellPepper && !isPeas && !isPumpkin) {
                    removeWords.push('red', 'green', 'yellow', 'white', 'black', 'purple');
                }
                // Protect "mixed" for bell peppers, "english" for cucumbers
                if (isBellPepper) {
                    const idx = removeWords.indexOf('mixed');
                    if (idx > -1) removeWords.splice(idx, 1);
                }
                if (isCucumber) {
                    const idx = removeWords.indexOf('english');
                    if (idx > -1) removeWords.splice(idx, 1);
                }
                // For bean/chickpea inputs, remove "peas" (noise from "chickpeas peas")
                if (isBean) {
                    removeWords.push('peas');
                }
                
                removeWords.forEach(word => {
                    const regex = new RegExp('\\b' + word + '\\b', 'gi');
                    normalized = normalized.replace(regex, '');
                });
                
                normalized = normalized.replace(/\s*\/\s*/g, '/');
                normalized = normalized.replace(/\s+/g, ' ').trim();
                normalized = normalized.replace(/\s*–\s*/g, ' ');
                normalized = normalized.replace(/\s*-\s*/g, ' ');
                normalized = normalized.replace(/\s+/g, ' ').trim();
                
                normalized = normalized.replace(/\bgarlic\s+clove[s]?\b/gi, 'garlic');
                
                const pluralMap = {
                    'tomatoes': 'tomato', 'potatoes': 'potato', 'onions': 'onion',
                    'carrots': 'carrot', 'peppers': 'pepper',
                    'chilies': 'chili', 'chillies': 'chili',
                    'lemons': 'lemon', 'limes': 'lime',
                    'leaves': 'leaf', 'bunches': 'bunch',
                };
                
                for (let [plural, singular] of Object.entries(pluralMap)) {
                    const regex = new RegExp('\\b' + plural + '\\b', 'gi');
                    normalized = normalized.replace(regex, singular);
                }
                
                return normalized;
            }

            function parseIngredientLine(line) {
                line = line.replace(/[\u2060\u200B\u200C\u200D\uFEFF]/g, '');
                line = line.trim();
                if (!line) return null;
                
                line = line.replace(/^[•\-\*]\s*/, '');
                line = line.replace(/^\d+[\.)]\s*/, '');
                line = line.trim();
                
                const parenContents = [];
                let protectedLine = line.replace(/\([^)]+\)/g, (match) => {
                    parenContents.push(match);
                    return `__PAREN_${parenContents.length - 1}__`;
                });

                const parsed = parseQuantity(protectedLine);
                let ingredientName = protectedLine;
                
                if (parsed.quantity > 0) {
                    const unitPattern = /(\d*\.?\d+\s*-\s*)?(\d*\.?\d+)\s*(lbs?|pounds?|oz|ounces?|gallons?|cups?|packs?|packets?|jars?|bottles?|blocks?|boxes?|bunches?|cartons?|stalks?|cloves?|count|cans?|tins?|bags?|sticks?|gms?|grams?)\b/gi;
                    const matches = [...protectedLine.matchAll(unitPattern)];
                    
                    if (matches.length > 0) {
                        const lastMatch = matches[matches.length - 1];
                        const beforeMatch = protectedLine.substring(0, lastMatch.index);
                        const afterMatch = protectedLine.substring(lastMatch.index + lastMatch[0].length);
                        ingredientName = (beforeMatch + afterMatch).trim();
                    } else {
                        const rangeMatches = [...protectedLine.matchAll(/(\d*\.?\d+)\s*-\s*(\d*\.?\d+)/g)];
                        if (rangeMatches.length > 0) {
                            const lastRangeMatch = rangeMatches[rangeMatches.length - 1];
                            const beforeRange = protectedLine.substring(0, lastRangeMatch.index);
                            const afterRange = protectedLine.substring(lastRangeMatch.index + lastRangeMatch[0].length);
                            ingredientName = (beforeRange + afterRange).trim();
                        } else {
                            const numberMatches = [...protectedLine.matchAll(/(\d*\.?\d+)/g)];
                            if (numberMatches.length > 0) {
                                const lastNumMatch = numberMatches[numberMatches.length - 1];
                                const beforeNum = protectedLine.substring(0, lastNumMatch.index);
                                const afterNum = protectedLine.substring(lastNumMatch.index + lastNumMatch[0].length);
                                ingredientName = (beforeNum + afterNum).trim();
                            }
                        }
                    }
                }
                
                ingredientName = ingredientName.replace(/__PAREN_(\d+)__/g, (match, index) => {
                    return parenContents[parseInt(index)];
                });

                ingredientName = normalizeIngredientName(ingredientName);
                
                // Filter out lines that are just noise/section headers after normalization
                const noiseOnlyWords = new Set(['from', 'for', 'the', 'and', 'or', 'with', 'a', 'an', 'of', 'to', 'in', 'on']);
                if (!ingredientName || ingredientName.length === 0 || noiseOnlyWords.has(ingredientName.trim())) {
                    return null;
                }

                const normalized = normalizeUnit(parsed.unit, parsed.quantity);

                return {
                    normalized: ingredientName,
                    quantity: normalized.quantity,
                    unit: normalized.unit,
                    isPantry: parsed.unit === 'pantry',
                    converted: normalized.converted
                };
            }

            function consolidateIngredients() {
                if (!masterData) {
                    alert('Please load master data first by entering your Google Sheets API key.');
                    return;
                }

                const allIngredients = {};
                const listStats = [];
                let totalInputItems = 0;
                let conversionsDetected = false;

                const numberedLists = lists.map(list => {
                    if (!list.trim()) return list;
                    const lines = list.split('\n');
                    let lineNumber = 1;
                    return lines.map(line => {
                        if (line.trim()) {
                            return `${lineNumber++}. ${line}`;
                        }
                        return '';
                    }).filter(line => line !== '').join('\n');
                });
                setLists(numberedLists);

                lists.forEach((list, listIndex) => {
                    if (!list.trim()) return;

                    let itemCount = 0;
                    const lines = list.split('\n');
                    
                    lines.forEach(line => {
                        const ingredient = parseIngredientLine(line);
                        if (!ingredient) return;

                        itemCount++;
                        totalInputItems++;
                        
                        if (ingredient.converted) {
                            conversionsDetected = true;
                        }

                        if (!allIngredients[ingredient.normalized]) {
                            allIngredients[ingredient.normalized] = {
                                quantities: {},
                                isPantry: ingredient.isPantry,
                                sources: [],
                                originalName: ingredient.normalized
                            };
                        }

                        const entry = allIngredients[ingredient.normalized];
                        
                        if (ingredient.isPantry) {
                            entry.isPantry = true;
                        } else {
                            if (!entry.quantities[ingredient.unit]) {
                                entry.quantities[ingredient.unit] = 0;
                            }
                            entry.quantities[ingredient.unit] += ingredient.quantity;
                            entry.isPantry = false;
                        }
                        
                        entry.sources.push(listIndex + 1);
                    });

                    if (itemCount > 0) {
                        listStats.push({
                            listNumber: listIndex + 1,
                            itemCount: itemCount
                        });
                    }
                });

                setHasConversions(conversionsDetected);

                // Step 1: Match with master data (don't consolidate yet)
                const needsMatching = {};
                const matchedIngredients = {};
                
                for (const [name, item] of Object.entries(allIngredients)) {
                    // Try exact match first
                    let masterMatch = masterData.lookup[name];
                    let matchStatus = 'exact';
                    
                    // If no exact match, try fuzzy matching with category context
                    if (!masterMatch) {
                        const fuzzyMatches = fuzzyMatchWithCategory(name, masterData);
                        
                        // Auto-match only for VERY high similarity (>95%) to avoid false matches
                        if (fuzzyMatches.length > 0 && fuzzyMatches[0].similarity > 0.95) {
                            // Auto-match if very high similarity (>95%)
                            masterMatch = fuzzyMatches[0].data;
                            matchStatus = 'auto-fuzzy';
                        } else if (fuzzyMatches.length > 0 && fuzzyMatches[0].similarity >= 0.5) {
                            // Show matches for user selection
                            // Don't filter too aggressively - show all reasonable matches
                            let filteredMatches = fuzzyMatches;
                            
                            // Only filter out very different categories if there's a strong category signal
                            const hasCategoryMatch = fuzzyMatches.some(m => m.categoryMatch);
                            const topSimilarity = fuzzyMatches[0].similarity;
                            
                            // Only filter if we have category matches AND non-category items are significantly worse
                            if (hasCategoryMatch && topSimilarity > 0.8) {
                                // Keep category matches + any high similarity items (>70%)
                                filteredMatches = fuzzyMatches.filter(m => 
                                    m.categoryMatch || m.similarity > 0.70
                                );
                            }
                            
                            if (filteredMatches.length > 0) {
                                // Store for user selection
                                needsMatching[name] = {
                                    item: item,
                                    matches: filteredMatches
                                };
                                matchStatus = 'needs-selection';
                            } else {
                                matchStatus = 'not-found';
                            }
                        } else {
                            matchStatus = 'not-found';
                        }
                    }
                    
                    // Store the matched ingredient with its standardized name
                    const standardizedName = masterMatch ? masterMatch.item : name;
                    matchedIngredients[name] = {
                        standardizedName: standardizedName,
                        masterData: masterMatch,
                        quantities: item.quantities,
                        isPantry: item.isPantry,
                        sources: item.sources,
                        matchStatus: matchStatus
                    };
                }

                // If there are items needing user selection, show modal
                if (Object.keys(needsMatching).length > 0) {
                    setPendingMatches(needsMatching);
                    setMatchSuggestions(Object.keys(needsMatching));
                    setShowMatchModal(true);
                    // Store matched ingredients for later consolidation
                    window.tempMatchedIngredients = matchedIngredients;
                    window.tempListStats = { listStats, totalInputItems };
                } else {
                    // No matching needed, proceed to consolidation
                    finalizeConsolidation(matchedIngredients, { listStats, totalInputItems });
                }
            }

            function finalizeConsolidation(matchedIngredients, stats) {
                // Step 2: Consolidate items with the same standardized name
                const consolidatedByStandardName = {};
                
                for (const [originalName, matchInfo] of Object.entries(matchedIngredients)) {
                    const stdName = matchInfo.standardizedName;
                    
                    if (!consolidatedByStandardName[stdName]) {
                        consolidatedByStandardName[stdName] = {
                            quantities: { ...matchInfo.quantities }, // Copy quantities from first occurrence
                            isPantry: matchInfo.isPantry,
                            sources: [...matchInfo.sources],
                            masterData: matchInfo.masterData,
                            matchStatus: matchInfo.matchStatus
                        };
                    } else {
                        // Merge quantities
                        const existing = consolidatedByStandardName[stdName];
                        for (const [unit, qty] of Object.entries(matchInfo.quantities)) {
                            if (!existing.quantities[unit]) {
                                existing.quantities[unit] = 0;
                            }
                            existing.quantities[unit] += qty;
                        }
                        // Merge sources
                        existing.sources = [...new Set([...existing.sources, ...matchInfo.sources])];
                        // Update pantry status
                        if (matchInfo.isPantry && !existing.isPantry) {
                            existing.isPantry = false; // If any instance has quantity, not pantry
                        }
                        // Keep best match status
                        if (matchInfo.matchStatus === 'exact') {
                            existing.matchStatus = 'exact';
                        }
                    }
                }

                // Step 3: Create final output
                const result = Object.entries(consolidatedByStandardName).map(([name, item]) => {
                    if (item.isPantry) {
                        return {
                            name: name,
                            count: 'pantry',
                            isPantry: true,
                            wasCombined: item.sources.length > 1,
                            defaultUnit: item.masterData?.defaultUnit || '',
                            preferredBrand: item.masterData?.preferredBrand || '',
                            category: item.masterData?.category || '',
                            preferredStore: item.masterData?.preferredStore || '',
                            altStore: item.masterData?.altStore || '',
                            matchStatus: item.matchStatus
                        };
                    }

                    const quantityStrings = Object.entries(item.quantities)
                        .map(([unit, qty]) => `${qty} ${unit}`);

                    return {
                        name: name,
                        count: quantityStrings.join(', '),
                        isPantry: false,
                        wasCombined: item.sources.length > 1,
                        defaultUnit: item.masterData?.defaultUnit || '',
                        preferredBrand: item.masterData?.preferredBrand || '',
                        category: item.masterData?.category || '',
                        preferredStore: item.masterData?.preferredStore || '',
                        altStore: item.masterData?.altStore || '',
                        matchStatus: item.matchStatus
                    };
                }).sort((a, b) => {
                    if (a.isPantry && !b.isPantry) return 1;
                    if (!a.isPantry && b.isPantry) return -1;
                    if (a.preferredStore !== b.preferredStore) {
                        return a.preferredStore.localeCompare(b.preferredStore);
                    }
                    return a.name.localeCompare(b.name);
                });

                setConsolidated(result);
                setSummary({
                    listStats: stats.listStats,
                    totalInputItems: stats.totalInputItems,
                    consolidatedCount: result.length,
                    itemsSaved: stats.totalInputItems - result.length
                });
            }

            function handleMatchSelection(ingredientName, selectedMatch) {
                // Update the temp matched ingredients with user selection
                if (window.tempMatchedIngredients) {
                    window.tempMatchedIngredients[ingredientName] = {
                        ...window.tempMatchedIngredients[ingredientName],
                        standardizedName: selectedMatch.item,
                        masterData: selectedMatch,
                        matchStatus: 'user-selected'
                    };
                }
                
                // Remove from pending
                const newPending = { ...pendingMatches };
                delete newPending[ingredientName];
                setPendingMatches(newPending);
                setMatchSuggestions(Object.keys(newPending));
                
                // If all matches resolved, finalize consolidation
                if (Object.keys(newPending).length === 0) {
                    setShowMatchModal(false);
                    if (window.tempMatchedIngredients && window.tempListStats) {
                        finalizeConsolidation(window.tempMatchedIngredients, window.tempListStats);
                        delete window.tempMatchedIngredients;
                        delete window.tempListStats;
                    }
                }
            }

            function skipMatch(ingredientName) {
                // Keep original name and mark as not-found
                if (window.tempMatchedIngredients) {
                    window.tempMatchedIngredients[ingredientName] = {
                        ...window.tempMatchedIngredients[ingredientName],
                        matchStatus: 'not-found'
                    };
                }
                
                const newPending = { ...pendingMatches };
                delete newPending[ingredientName];
                setPendingMatches(newPending);
                setMatchSuggestions(Object.keys(newPending));
                
                // If all matches resolved, finalize consolidation
                if (Object.keys(newPending).length === 0) {
                    setShowMatchModal(false);
                    if (window.tempMatchedIngredients && window.tempListStats) {
                        finalizeConsolidation(window.tempMatchedIngredients, window.tempListStats);
                        delete window.tempMatchedIngredients;
                        delete window.tempListStats;
                    }
                }
            }

            function copyToGoogleSheets() {
                const headers = ['Items', 'Units', 'Default Unit', 'Preferred Brand', 'Category', 'Preferred Store', 'Alt Store'];
                const rows = consolidated.map(item => [
                    item.name, 
                    item.count, 
                    item.defaultUnit, 
                    item.preferredBrand, 
                    item.category, 
                    item.preferredStore, 
                    item.altStore
                ]);
                const tsvContent = [headers, ...rows].map(row => row.join('\t')).join('\n');

                navigator.clipboard.writeText(tsvContent).then(() => {
                    setCopyStatus('✓ Copied! Paste into Google Sheets');
                    setTimeout(() => setCopyStatus(''), 3000);
                }).catch(() => {
                    setCopyStatus('Failed to copy');
                    setTimeout(() => setCopyStatus(''), 3000);
                });
            }

            function getUpcomingDay(targetDay) {
                // targetDay: 0=Sunday, 5=Friday
                const today = new Date();
                const day = today.getDay();
                const daysUntil = (targetDay - day + 7) % 7 || 7;
                const result = new Date(today);
                result.setDate(today.getDate() + daysUntil);
                return result;
            }

            function formatTabName(date) {
                const mm = String(date.getMonth() + 1).padStart(2, '0');
                const dd = String(date.getDate()).padStart(2, '0');
                const yyyy = date.getFullYear();
                return `${mm}/${dd}/${yyyy}`;
            }

            // Listen for OAuth2 token returned via postMessage from popup
            useEffect(() => {
                function handleMessage(event) {
                    if (event.origin !== window.location.origin) return;
                    if (event.data && event.data.type === 'oauth2_token') {
                        setOauthToken(event.data.access_token);
                        setOauthUser(event.data.email || 'Signed in');
                    } else if (event.data && event.data.type === 'oauth2_error') {
                        setSubmitStatus('✗ Sign-in error: ' + event.data.error);
                        setTimeout(() => setSubmitStatus(''), 5000);
                    }
                }
                window.addEventListener('message', handleMessage);
                return () => window.removeEventListener('message', handleMessage);
            }, []);

            function signInWithGoogle() {
                const SCOPE = 'https://www.googleapis.com/auth/spreadsheets';
                const redirectUri = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/oauth2callback.html');
                const params = new URLSearchParams({
                    client_id: OAUTH_CLIENT_ID,
                    redirect_uri: redirectUri,
                    response_type: 'token',
                    scope: SCOPE,
                    include_granted_scopes: 'true',
                    prompt: 'select_account'
                });
                const width = 500, height = 600;
                const left = window.screenX + (window.outerWidth - width) / 2;
                const top = window.screenY + (window.outerHeight - height) / 2;
                window.open(
                    'https://accounts.google.com/o/oauth2/v2/auth?' + params.toString(),
                    'googleAuth',
                    `width=${width},height=${height},left=${left},top=${top}`
                );
            }

            function signOutGoogle() {
                if (oauthToken) {
                    fetch(`https://oauth2.googleapis.com/revoke?token=${oauthToken}`, { method: 'POST' }).catch(() => {});
                }
                setOauthToken(null);
                setOauthUser('');
            }

            async function submitToGoogleSheets() {
                if (!consolidated.length) return;

                if (!oauthToken) {
                    setSubmitStatus('✗ Please sign in with Google first');
                    setTimeout(() => setSubmitStatus(''), 4000);
                    return;
                }

                const freshToken = oauthToken;
                const SUBMIT_SHEET_ID = '1UbBBupMUuF8m4Ax8B8Vfid2ojqa0nt4bbOxG4JpmyI4';
                const targetDayNum = submitDay === 'friday' ? 5 : 0;
                const targetDate = getUpcomingDay(targetDayNum);
                const tabName = formatTabName(targetDate);

                setSubmitStatus('⏳ Submitting...');

                try {
                    // Step 1: Always read existing tab data first (reliable tab-exists detection)
                    setSubmitStatus('⏳ Checking for existing data...');
                    const existingRes = await fetch(
                        `https://sheets.googleapis.com/v4/spreadsheets/${SUBMIT_SHEET_ID}/values/${encodeURIComponent(tabName) + '!A:G'}`,
                        { headers: { 'Authorization': `Bearer ${freshToken}` } }
                    );

                    // Step 2: Merge if existing data found, otherwise use consolidated as-is
                    let finalItems = [...consolidated];
                    const existingData = existingRes.ok ? await existingRes.json() : null;
                    const rawValues = existingData ? (existingData.values || []) : [];

                    // Detect if header row is present; skip it
                    const hasHeader = rawValues.length > 0 && (rawValues[0][0] || '').toLowerCase() === 'items';
                    const existingRows = hasHeader ? rawValues.slice(1) : rawValues;
                    const tabAlreadyExists = existingRows.length > 0;

                    console.log('[SUBMIT] existingRes.ok:', existingRes.ok,
                        '| rawValues rows:', rawValues.length,
                        '| hasHeader:', hasHeader,
                        '| existingRows:', existingRows.length,
                        '| tabAlreadyExists:', tabAlreadyExists);

                    if (tabAlreadyExists) {
                        setSubmitStatus('\u23f3 Tab exists \u2014 merging...');

                        // Build lookup from existing sheet rows
                        const existingByName = {};
                        existingRows.forEach(row => {
                            const name = (row[0] || '').trim();
                            if (!name) return;
                            const unitsStr = (row[1] || '').trim();
                            const quantities = {};
                            unitsStr.split(',').forEach(part => {
                                part = part.trim();
                                if (part === 'pantry') { quantities['pantry'] = 0; return; }
                                const m = part.match(/^([\d.]+)\s+(.+)$/);
                                if (m) quantities[m[2].trim()] = parseFloat(m[1]);
                                else console.warn('[MERGE] could not parse units part:', JSON.stringify(part));
                            });
                            existingByName[name.toLowerCase()] = {
                                name, quantities,
                                isPantry: unitsStr === 'pantry',
                                defaultUnit: row[2] || '', preferredBrand: row[3] || '',
                                category: row[4] || '', preferredStore: row[5] || '',
                                altStore: row[6] || '', matchStatus: 'exact', wasCombined: false
                            };
                        });

                        console.log('[MERGE] existing keys:', Object.keys(existingByName));
                        console.log('[MERGE] new item keys:', consolidated.map(i => i.name.toLowerCase() + '=' + i.count));

                        const mergedByName = { ...existingByName };

                        consolidated.forEach(item => {
                            const key = item.name.toLowerCase();
                            if (mergedByName[key]) {
                                const existing = mergedByName[key];
                                if (!item.isPantry && item.count !== 'pantry') {
                                    const newQtys = {};
                                    item.count.split(',').forEach(part => {
                                        part = part.trim();
                                        const m = part.match(/^([\d.]+)\s+(.+)$/);
                                        if (m) newQtys[m[2].trim()] = parseFloat(m[1]);
                                        else console.warn('[MERGE] could not parse new count part:', JSON.stringify(part));
                                    });
                                    console.log('[MERGE] summing', key, '| existing:', {...existing.quantities}, '+ new:', newQtys);
                                    Object.entries(newQtys).forEach(([unit, qty]) => {
                                        existing.quantities[unit] = (existing.quantities[unit] || 0) + qty;
                                    });
                                    console.log('[MERGE] result:', existing.quantities);
                                    existing.isPantry = false;
                                }
                                existing.wasCombined = true;
                                if (item.defaultUnit) existing.defaultUnit = item.defaultUnit;
                                if (item.preferredBrand) existing.preferredBrand = item.preferredBrand;
                                if (item.category) existing.category = item.category;
                                if (item.preferredStore) existing.preferredStore = item.preferredStore;
                                if (item.altStore) existing.altStore = item.altStore;
                            } else {
                                const newQtys = {};
                                if (item.count !== 'pantry') {
                                    item.count.split(',').forEach(part => {
                                        part = part.trim();
                                        const m = part.match(/^([\d.]+)\s+(.+)$/);
                                        if (m) newQtys[m[2].trim()] = parseFloat(m[1]);
                                    });
                                }
                                mergedByName[key] = {
                                    name: item.name, quantities: newQtys,
                                    isPantry: item.isPantry,
                                    defaultUnit: item.defaultUnit, preferredBrand: item.preferredBrand,
                                    category: item.category, preferredStore: item.preferredStore,
                                    altStore: item.altStore, matchStatus: item.matchStatus, wasCombined: false
                                };
                                console.log('[MERGE] appended new item:', key, item.count);
                            }
                        });

                        finalItems = Object.values(mergedByName).map(item => {
                            const count = (item.isPantry || Object.keys(item.quantities).length === 0)
                                ? 'pantry'
                                : Object.entries(item.quantities).map(([u, q]) => q + ' ' + u).join(', ');
                            return { ...item, count };
                        }).sort((a, b) => {
                            if (a.isPantry && !b.isPantry) return 1;
                            if (!a.isPantry && b.isPantry) return -1;
                            if (a.preferredStore !== b.preferredStore)
                                return a.preferredStore.localeCompare(b.preferredStore);
                            return a.name.localeCompare(b.name);
                        });

                        console.log('[MERGE] final:', finalItems.map(i => i.name + ' | ' + i.count));
                        setSubmitStatus('\u23f3 Merged \u2014 writing to sheet...');
                    }

                    // Step 3: Create tab if it doesn't exist yet
                    if (!tabAlreadyExists) {
                        const addSheetRes = await fetch(
                            `https://sheets.googleapis.com/v4/spreadsheets/${SUBMIT_SHEET_ID}:batchUpdate`,
                            {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${freshToken}` },
                                body: JSON.stringify({ requests: [{ addSheet: { properties: { title: tabName } } }] })
                            }
                        );
                        if (!addSheetRes.ok) {
                            const addErr = await addSheetRes.json().catch(() => ({}));
                            const msg = (addErr.error?.message || '').toLowerCase();
                            if (!msg.includes('already exists')) {
                                throw new Error(addErr.error?.message || 'Failed to create sheet tab');
                            }
                        }
                    }

                    // Step 4a: Write merged data
                    const headers = ['Items', 'Units', 'Default Unit', 'Preferred Brand', 'Category', 'Preferred Store', 'Alt Store'];
                    const rows = finalItems.map(item => [
                        item.name, item.count, item.defaultUnit,
                        item.preferredBrand, item.category, item.preferredStore, item.altStore
                    ]);

                    // Clear entire sheet first to remove any stale rows from previous submission
                    await fetch(
                        `https://sheets.googleapis.com/v4/spreadsheets/${SUBMIT_SHEET_ID}/values/${encodeURIComponent(tabName) + '!A:G'}:clear`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${freshToken}` }
                        }
                    );

                    const writeRes = await fetch(
                        `https://sheets.googleapis.com/v4/spreadsheets/${SUBMIT_SHEET_ID}/values/${encodeURIComponent(tabName) + '!A1'}?valueInputOption=RAW`,
                        {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${freshToken}` },
                            body: JSON.stringify({ values: [headers, ...rows] })
                        }
                    );

                    if (!writeRes.ok) {
                        const err = await writeRes.json();
                        throw new Error(err.error?.message || 'Failed to write data');
                    }

                    // Step 4b: Get sheet's numeric ID for formatting
                    const metaRes = await fetch(
                        `https://sheets.googleapis.com/v4/spreadsheets/${SUBMIT_SHEET_ID}?fields=sheets.properties`,
                        { headers: { 'Authorization': `Bearer ${freshToken}` } }
                    );
                    const meta = await metaRes.json();
                    const sheetObj = meta.sheets.find(s => s.properties.title === tabName);
                    const sheetId = sheetObj ? sheetObj.properties.sheetId : 0;

                    // Step 4c: Apply formatting
                    const colorMap = {
                        'not-found':      { red: 1,    green: 0.8,  blue: 0.8  },
                        'pantry-single':  { red: 1,    green: 0.98, blue: 0.94 },
                        'pantry-combined':{ red: 1,    green: 0.91, blue: 0.71 },
                        'consolidated':   { red: 0.88, green: 0.96, blue: 0.88 },
                        'normal':         { red: 1,    green: 1,    blue: 1    }
                    };

                    function getRowColor(item) {
                        if (item.matchStatus === 'not-found') return colorMap['not-found'];
                        if (item.isPantry && item.wasCombined) return colorMap['pantry-combined'];
                        if (item.isPantry) return colorMap['pantry-single'];
                        if (item.wasCombined) return colorMap['consolidated'];
                        return colorMap['normal'];
                    }

                    const formatRequests = [];

                    formatRequests.push({
                        repeatCell: {
                            range: { sheetId, startRowIndex: 0, endRowIndex: 1, startColumnIndex: 0, endColumnIndex: 7 },
                            cell: {
                                userEnteredFormat: {
                                    textFormat: { bold: true, foregroundColor: { red: 1, green: 1, blue: 1 } },
                                    backgroundColor: { red: 0.26, green: 0.26, blue: 0.26 },
                                    verticalAlignment: 'MIDDLE'
                                }
                            },
                            fields: 'userEnteredFormat(textFormat,backgroundColor,verticalAlignment)'
                        }
                    });

                    finalItems.forEach((item, i) => {
                        const color = getRowColor(item);
                        formatRequests.push({
                            repeatCell: {
                                range: { sheetId, startRowIndex: i + 1, endRowIndex: i + 2, startColumnIndex: 0, endColumnIndex: 7 },
                                cell: { userEnteredFormat: { backgroundColor: color } },
                                fields: 'userEnteredFormat.backgroundColor'
                            }
                        });
                    });

                    formatRequests.push({
                        updateSheetProperties: {
                            properties: { sheetId, gridProperties: { frozenRowCount: 1 } },
                            fields: 'gridProperties.frozenRowCount'
                        }
                    });

                    formatRequests.push({
                        autoResizeDimensions: {
                            dimensions: { sheetId, dimension: 'COLUMNS', startIndex: 0, endIndex: 7 }
                        }
                    });

                    await fetch(
                        `https://sheets.googleapis.com/v4/spreadsheets/${SUBMIT_SHEET_ID}:batchUpdate`,
                        {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${freshToken}` },
                            body: JSON.stringify({ requests: formatRequests })
                        }
                    );

                    const mergeNote = finalItems.length !== consolidated.length || tabAlreadyExists
                        ? ` (merged ${finalItems.length} items)` : '';
                    setSubmitStatus(`✓ Submitted to tab "${tabName}"${mergeNote}`);
                    setTimeout(() => setSubmitStatus(''), 6000);
                } catch (error) {
                    setSubmitStatus(`✗ Error: ${error.message}`);
                    setTimeout(() => setSubmitStatus(''), 6000);
                }
            }

            function addNewList() {
                setLists([...lists, '']);
            }

            function removeList(index) {
                if (lists.length <= 1) return;
                const newLists = lists.filter((_, i) => i !== index);
                setLists(newLists);
            }

            return (
                <div className="min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 py-8 px-4">
                    <div className="max-w-6xl mx-auto">
                        <div className="text-center mb-8">
                            <h1 className="text-4xl font-bold text-gray-800 mb-2">🛒 Ingredient List Consolidator</h1>
                            <p className="text-gray-600">Combine multiple ingredient lists with master data integration</p>
                        </div>

                        {/* Master Data Status */}
                        {masterData && (
                            <div className="bg-green-50 rounded-lg p-4 mb-6 border border-green-200">
                                <p className="text-green-800 font-semibold">
                                    ✓ Loaded Master List Annapurna ({Object.keys(masterData.lookup).length} items)
                                </p>
                            </div>
                        )}
                        {!masterData && (
                            <div className="bg-yellow-50 rounded-lg p-4 mb-6 border border-yellow-200">
                                <p className="text-yellow-800 font-semibold">
                                    ⚠ Master data not loaded. Please configure API key in the code.
                                </p>
                            </div>
                        )}

                        {/* Google Sign-In for Submit */}
                        <div className="bg-white rounded-xl shadow-sm p-4 mb-6 border border-gray-200 flex items-center justify-between">
                            <div>
                                <p className="text-sm font-semibold text-gray-700">Google Account — required for Submit</p>
                                <p className="text-xs text-gray-500 mt-0.5">
                                    {oauthToken ? `Signed in as ${oauthUser}` : 'Sign in to enable writing to the shopping sheet'}
                                </p>
                            </div>
                            {!oauthToken ? (
                                <button
                                    onClick={signInWithGoogle}
                                    className="flex items-center gap-2 px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 text-sm font-medium text-gray-700 transition-colors"
                                >
                                    <svg className="w-5 h-5" viewBox="0 0 24 24">
                                        <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                        <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                        <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l3.66-2.84z"/>
                                        <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                                    </svg>
                                    Sign in with Google
                                </button>
                            ) : (
                                <button
                                    onClick={signOutGoogle}
                                    className="px-4 py-2 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg text-sm font-medium transition-colors"
                                >
                                    Sign Out
                                </button>
                            )}
                        </div>

                        {/* Input Lists */}
                        <div className="bg-white rounded-xl shadow-lg p-8 mb-6">
                            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                                {lists.map((list, index) => (
                                    <div key={index} className="relative">
                                        <div className="flex justify-between items-center mb-2">
                                            <label className="block text-sm font-semibold text-gray-700">
                                                List {index + 1}
                                            </label>
                                            {lists.length > 1 && (
                                                <button
                                                    onClick={() => removeList(index)}
                                                    className="text-red-500 hover:text-red-700 text-sm font-medium"
                                                >
                                                    Remove
                                                </button>
                                            )}
                                        </div>
                                        <textarea
                                            value={list}
                                            onChange={(e) => {
                                                const newLists = [...lists];
                                                newLists[index] = e.target.value;
                                                setLists(newLists);
                                            }}
                                            placeholder="Paste ingredients here (line-separated)..."
                                            className="w-full h-32 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                        />
                                    </div>
                                ))}
                            </div>

                            <div className="flex gap-3 justify-center">
                                <button
                                    onClick={addNewList}
                                    className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-colors"
                                >
                                    + Add Another List
                                </button>
                                <button
                                    onClick={consolidateIngredients}
                                    className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors"
                                    disabled={!masterData}
                                >
                                    Consolidate Lists
                                </button>
                            </div>
                        </div>

                        {/* Match Selection Modal */}
                        {showMatchModal && (
                            <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                                <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-[80vh] overflow-y-auto p-6">
                                    <h2 className="text-2xl font-bold text-gray-800 mb-4">Select Matching Items</h2>
                                    <p className="text-gray-600 mb-6">
                                        Some ingredients don't have exact matches. Please select the best match or skip.
                                    </p>
                                    
                                    {matchSuggestions.map(ingredientName => (
                                        <div key={ingredientName} className="mb-6 p-4 border border-gray-200 rounded-lg">
                                            <h3 className="font-semibold text-lg text-gray-800 mb-3">
                                                "{ingredientName}"
                                            </h3>
                                            <div className="space-y-2">
                                                {pendingMatches[ingredientName].matches.map((match, idx) => (
                                                    <button
                                                        key={idx}
                                                        onClick={() => handleMatchSelection(ingredientName, match.data)}
                                                        className={`w-full text-left p-3 border rounded-lg transition-colors ${
                                                            match.categoryMatch 
                                                                ? 'border-blue-400 bg-blue-50 hover:bg-blue-100' 
                                                                : 'border-gray-300 hover:bg-gray-50'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between items-center">
                                                            <span className="font-medium">{match.data.item}</span>
                                                            <div className="flex items-center gap-2">
                                                                {match.categoryMatch && (
                                                                    <span className="text-xs bg-blue-200 text-blue-800 px-2 py-1 rounded">
                                                                        Category Match
                                                                    </span>
                                                                )}
                                                                <span className="text-sm text-gray-500">
                                                                    {Math.round(match.similarity * 100)}% match
                                                                </span>
                                                            </div>
                                                        </div>
                                                        <div className="text-sm text-gray-600 mt-1">
                                                            {match.data.category && `Category: ${match.data.category}`}
                                                            {match.data.preferredStore && ` • Store: ${match.data.preferredStore}`}
                                                        </div>
                                                    </button>
                                                ))}
                                                <button
                                                    onClick={() => skipMatch(ingredientName)}
                                                    className="w-full p-3 border border-gray-300 rounded-lg hover:bg-gray-50 text-gray-600 font-medium"
                                                >
                                                    Skip - Keep as "{ingredientName}"
                                                </button>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}

                        {/* Summary Statistics */}
                        {summary && (
                            <div className="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl shadow-lg p-6 mb-6 border border-blue-200">
                                <h2 className="text-xl font-bold text-gray-800 mb-4">📊 Summary Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div className="bg-white rounded-lg p-4 shadow-sm">
                                        <h3 className="font-semibold text-gray-700 mb-3">Input Lists</h3>
                                        <div className="space-y-2">
                                            {summary.listStats.map((stat, index) => (
                                                <div key={index} className="flex justify-between items-center">
                                                    <span className="text-gray-600">List {stat.listNumber}:</span>
                                                    <span className="font-semibold text-blue-600">{stat.itemCount} items</span>
                                                </div>
                                            ))}
                                            <div className="border-t pt-2 mt-2 flex justify-between items-center">
                                                <span className="font-semibold text-gray-700">Total Input:</span>
                                                <span className="font-bold text-lg text-blue-700">{summary.totalInputItems} items</span>
                                            </div>
                                        </div>
                                    </div>
                                    <div className="bg-white rounded-lg p-4 shadow-sm">
                                        <h3 className="font-semibold text-gray-700 mb-3">Consolidation Result</h3>
                                        <div className="space-y-2">
                                            <div className="flex justify-between items-center">
                                                <span className="text-gray-600">Final List:</span>
                                                <span className="font-semibold text-green-600">{summary.consolidatedCount} items</span>
                                            </div>
                                            <div className="flex justify-between items-center">
                                                <span className="text-gray-600">Items Combined:</span>
                                                <span className="font-semibold text-orange-600">{summary.itemsSaved} items</span>
                                            </div>
                                            <div className="border-t pt-2 mt-2">
                                                <div className="bg-green-100 rounded p-2 text-center">
                                                    <span className="text-green-800 font-semibold">
                                                        ✓ Reduced by {summary.totalInputItems > 0 ? Math.round((summary.itemsSaved / summary.totalInputItems) * 100) : 0}%
                                                    </span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Results Table */}
                        {consolidated.length > 0 && (
                            <div className="bg-white rounded-xl shadow-lg p-8">
                                {hasConversions && (
                                    <div className="mb-4 text-xs text-gray-500 italic">
                                        Note: Cups have been converted to lbs (1 cup = 0.5 lbs)
                                    </div>
                                )}
                                <div className="flex justify-between items-center mb-6">
                                    <div>
                                        <h2 className="text-2xl font-bold text-gray-800">Shopping List</h2>
                                        <p className="text-sm text-gray-600 mt-1">
                                            <span className="inline-block w-4 h-4 bg-green-100 border border-green-300 mr-1"></span>
                                            Consolidated items
                                            <span className="inline-block w-4 h-4 bg-amber-50 border border-amber-300 ml-3 mr-1"></span>
                                            Pantry items
                                            <span className="inline-block w-4 h-4 bg-amber-200 border border-amber-400 ml-3 mr-1"></span>
                                            Combined pantry
                                            <span className="inline-block w-4 h-4 bg-red-100 border border-red-300 ml-3 mr-1"></span>
                                            Not found
                                        </p>
                                    </div>
                                    <div className="flex flex-col items-end gap-2">
                                        <div className="flex gap-3 items-center flex-wrap justify-end">
                                            <button
                                                onClick={copyToGoogleSheets}
                                                className="px-6 py-2 bg-green-600 hover:bg-green-700 text-white rounded-lg font-semibold transition-colors flex items-center gap-2"
                                            >
                                                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                                                </svg>
                                                Copy to Google Sheets
                                            </button>
                                            <div className="flex items-center gap-2">
                                                <select
                                                    value={submitDay}
                                                    onChange={(e) => setSubmitDay(e.target.value)}
                                                    className="px-3 py-2 border border-gray-300 rounded-lg text-sm font-medium text-gray-700 bg-white focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                                                >
                                                    <option value="friday">Friday</option>
                                                    <option value="sunday">Sunday</option>
                                                </select>
                                                <button
                                                    onClick={submitToGoogleSheets}
                                                    className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-colors flex items-center gap-2"
                                                >
                                                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
                                                    </svg>
                                                    Submit — {submitDay === 'friday' ? 'Friday' : 'Sunday'} {formatTabName(getUpcomingDay(submitDay === 'friday' ? 5 : 0))}
                                                </button>
                                            </div>
                                        </div>
                                        {copyStatus && (
                                            <span className={`text-sm font-medium ${copyStatus.includes('✓') ? 'text-green-600' : 'text-red-600'}`}>
                                                {copyStatus}
                                            </span>
                                        )}
                                        {submitStatus && (
                                            <span className={`text-sm font-medium ${submitStatus.includes('✓') ? 'text-blue-600' : submitStatus.includes('⏳') ? 'text-gray-500' : 'text-red-600'}`}>
                                                {submitStatus}
                                            </span>
                                        )}
                                    </div>
                                </div>
                                
                                <div className="overflow-x-auto">
                                    <table className="w-full border-collapse">
                                        <thead>
                                            <tr className="bg-gray-100">
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Items</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Units</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Default Unit</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Preferred Brand</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Category</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Preferred Store</th>
                                                <th className="border border-gray-300 px-4 py-3 text-left font-semibold">Alt Store</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {consolidated.map((item, index) => {
                                                let rowClass = "hover:bg-gray-50";
                                                
                                                if (item.matchStatus === 'not-found') {
                                                    rowClass = "bg-red-100 border-l-4 border-l-red-500";
                                                } else if (item.isPantry) {
                                                    if (item.wasCombined) {
                                                        rowClass = "bg-amber-200 border-l-4 border-l-amber-600";
                                                    } else {
                                                        rowClass = "bg-amber-50 border-l-4 border-l-amber-500";
                                                    }
                                                } else if (item.wasCombined) {
                                                    rowClass = "bg-green-100 border-l-4 border-l-green-500";
                                                }
                                                
                                                return (
                                                    <tr key={index} className={rowClass}>
                                                        <td className="border border-gray-300 px-4 py-2">{item.name}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.count}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.defaultUnit}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.preferredBrand}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.category}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.preferredStore}</td>
                                                        <td className="border border-gray-300 px-4 py-2">{item.altStore}</td>
                                                    </tr>
                                                );
                                            })}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<IngredientConsolidator />, document.getElementById('root'));
    </script>
</body>
</html>
